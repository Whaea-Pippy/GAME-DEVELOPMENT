
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAW Patrol Maze Adventure</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            background-image: url('https://wallpapercave.com/wp/wp4015019.jpg');
            background-size: cover;
            background-position: center;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            overflow: auto;
            box-sizing: border-box;
        }
        h1 {
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 15px;
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            margin-bottom: 15px;
            text-align: center;
        }
        .game-container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }
        .maze-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .maze-container {
            position: relative;
        }
        canvas {
            border: 8px solid #ffde00;
            border-radius: 15px;
            touch-action: none;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 80vh;
            display: block;
        }
        .character-img {
            position: absolute;
            width: clamp(40px, 10vw, 80px); /* Increased size */
            height: auto;
            z-index: 10;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Make sure they don't block canvas events */
        }
        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 15px;
        }
        .control-group { display: flex; flex-direction: column; gap: 10px; }
        .control-group h3 { color: white; margin: 0 0 5px 0; text-align: center; font-size: clamp(1rem, 3vw, 1.2rem); }
        button {
            padding: 10px 15px;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            cursor: pointer;
            border: none;
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-weight: bold;
        }
        button:hover { transform: translateY(-3px); box-shadow: 0 6px 8px rgba(0,0,0,0.4); }
        button:active { transform: translateY(1px); box-shadow: 0 2px 3px rgba(0,0,0,0.3); }

        .difficulty-buttons, .action-buttons { display: flex; flex-direction: column; gap: 10px; }
        .difficulty-button { background-color: #5bc0de; }
        #toggleSolution { background-color: #007bff; }
        #generateNew, #playAgainBtn { background-color: #f0ad4e; }
        #clearTrace { background-color: #d9534f; }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: linear-gradient(145deg, #ff7e5f, #feb47b);
            margin: auto;
            padding: 40px;
            border: 10px solid #ffde00;
            border-radius: 25px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            animation: modal-pop 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        @keyframes modal-pop {
            from { transform: scale(0.5) rotate(-15deg); opacity: 0; }
            to { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        .modal-text {
            font-size: clamp(2rem, 10vw, 4rem);
            color: white;
            font-weight: bold;
            text-shadow: 3px 3px 0 #c7522f, -1px -1px 0 #c7522f, 1px -1px 0 #c7522f, -1px 1px 0 #c7522f, 1px 1px 0 #c7522f;
            margin-bottom: 25px;
        }

        @media (max-width: 768px) and (orientation: portrait) {
            body { justify-content: flex-start; padding-top: 20px; }
            .game-container { flex-direction: column; align-items: center; gap: 15px; }
            .maze-area { order: 1; }
            .controls-panel { order: 2; width: 100%; max-width: 400px; }
            .control-group { width: 100%; align-items: center; }
            .difficulty-buttons, .action-buttons { flex-direction: row; justify-content: center; flex-wrap: wrap; }
            canvas { max-height: 65vh; }
        }
    </style>
</head>
<body>
    <h1>PAW Patrol Maze Adventure!</h1>
    <div class="game-container">
        <div class="maze-area">
             <div class="maze-container">
                <canvas id="mazeCanvas"></canvas>
                <img id="start-img" class="character-img" src="https://drive.google.com/uc?id=1ssi1qNlo9V5Lv_5kBEpxP6nRMNQZxU3N" alt="Chase">
                <img id="end-img" class="character-img" src="https://drive.google.com/uc?id=1e7XEk5xF3Hjto3Q89kr8J8pRwgWNDCpE" alt="Mayor Humdinger">
            </div>
        </div>
        <div class="controls-panel">
            <div class="control-group">
                <h3>Difficulty</h3>
                <div class="difficulty-buttons">
                    <button id="easyBtn" class="difficulty-button">Easy</button>
                    <button id="mediumBtn" class="difficulty-button">Medium</button>
                    <button id="hardBtn" class="difficulty-button">Hard</button>
                </div>
            </div>
             <div class="control-group">
                <h3>Actions</h3>
                <div class="action-buttons">
                    <button id="toggleSolution">Solution</button>
                    <button id="generateNew">New Maze</button>
                    <button id="clearTrace">Clear</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Win Modal -->
    <div id="winModal" class="modal">
        <div class="modal-content">
            <p class="modal-text">PAW-some!</p>
            <button id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const startImg = document.getElementById('start-img');
        const endImg = document.getElementById('end-img');
        const winModal = document.getElementById('winModal');

        let cols, rows, cellSize;
        let maze, start, end;
        let userTrace = [], solutionPath = [];
        let showSolution = false, isDrawing = false, gameWon = false;
        let animationFrameId = null, solutionAnimationStartTime = null;
        const solutionAnimationDuration = 4000;
        let currentDifficultyKey = 'hard';

        const difficulties = {
            easy:   { landscape: { cols: 12, rows: 8 },  portrait: { cols: 8, rows: 12 } },
            medium: { landscape: { cols: 24, rows: 16 }, portrait: { cols: 16, rows: 24 } },
            hard:   { landscape: { cols: 30, rows: 20 }, portrait: { cols: 20, rows: 30 } }
        };

        function setDifficulty(difficulty) {
            currentDifficultyKey = difficulty;
            resizeAndGenerate();
        }

        function resizeAndGenerate() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            const isPortrait = window.matchMedia("(max-width: 768px) and (orientation: portrait)").matches;
            const difficulty = difficulties[currentDifficultyKey][isPortrait ? 'portrait' : 'landscape'];

            cols = difficulty.cols;
            rows = difficulty.rows;
            
            const controlsHeight = isPortrait ? document.querySelector('.controls-panel').offsetHeight : 0;
            const availableHeight = window.innerHeight * 0.9 - controlsHeight - (isPortrait ? 100 : 80);
            const controlsWidth = isPortrait ? 0 : document.querySelector('.controls-panel').offsetWidth;
            const availableWidth = window.innerWidth - controlsWidth - (isPortrait ? 40 : 80);

            const mazeAspectRatio = cols / rows;
            let canvasWidth = availableWidth;
            let canvasHeight = canvasWidth / mazeAspectRatio;

            if (canvasHeight > availableHeight) {
                canvasHeight = availableHeight;
                canvasWidth = canvasHeight * mazeAspectRatio;
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            cellSize = canvas.width / cols;

            generateNewMaze(isPortrait);
        }

        function updateCharacterPositions(isPortrait) {
            const startPos = getCellCenter(start);
            const endPos = getCellCenter(end);
            
            if(isPortrait){
                startImg.style.left = `${startPos.x}px`;
                startImg.style.top = `${-startImg.height / 2 + 5}px`;
                endImg.style.left = `${endPos.x}px`;
                endImg.style.top = `${canvas.height + endImg.height / 2 - 5}px`;
            } else {
                startImg.style.left = `${-startImg.width / 2 + 5}px`;
                startImg.style.top = `${startPos.y}px`;
                endImg.style.left = `${canvas.width + endImg.width / 2 - 5}px`;
                endImg.style.top = `${endPos.y}px`;
            }
        }

        function initMaze(isPortrait) {
            maze = Array(rows).fill(null).map(() => Array(cols).fill(null).map(() => ({ up: true, down: true, left: true, right: true, visited: false })));
            
            if(isPortrait){
                start = { row: 0, col: Math.floor(Math.random() * cols) };
                end = { row: rows - 1, col: Math.floor(Math.random() * cols) };
                maze[start.row][start.col].up = false;
                maze[end.row][end.col].down = false;
            } else {
                start = { row: Math.floor(Math.random() * rows), col: 0 };
                const lowerHalfStartRow = Math.floor(rows / 2);
                end = { row: lowerHalfStartRow + Math.floor(Math.random() * (rows - lowerHalfStartRow)), col: cols - 1 };
                maze[start.row][start.col].left = false;
                maze[end.row][end.col].right = false;
            }
        }

        function generateMazeRecursive(row, col) {
            maze[row][col].visited = true;
            const directions = shuffle([ { dr: -1, dc: 0, wall: 'up', oppWall: 'down' }, { dr: 1, dc: 0, wall: 'down', oppWall: 'up' }, { dr: 0, dc: -1, wall: 'left', oppWall: 'right' }, { dr: 0, dc: 1, wall: 'right', oppWall: 'left' } ]);
            for (const { dr, dc, wall, oppWall } of directions) {
                const newRow = row + dr, newCol = col + dc;
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !maze[newRow][newCol].visited) {
                    maze[row][col][wall] = false;
                    maze[newRow][newCol][oppWall] = false;
                    generateMazeRecursive(newRow, newCol);
                }
            }
        }

        function findSolution() {
            const queue = [{ ...start, path: [start] }];
            const visited = new Set([`${start.row}-${start.col}`]);
            while (queue.length > 0) {
                const { row, col, path } = queue.shift();
                if (row === end.row && col === end.col) return path;
                for (const dir of ['up', 'down', 'left', 'right']) {
                    if (!maze[row][col][dir]) {
                        let newRow = row, newCol = col;
                        if (dir === 'up') newRow--; else if (dir === 'down') newRow++;
                        if (dir === 'left') newCol--; else if (dir === 'right') newCol++;
                        const key = `${newRow}-${newCol}`;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited.has(key)) {
                            visited.add(key);
                            queue.push({ row: newRow, col: newCol, path: [...path, { row: newRow, col: newCol }] });
                        }
                    }
                }
            }
            return [];
        }

        function mainDrawLoop(timestamp) {
            animationFrameId = requestAnimationFrame(mainDrawLoop);
            clearCanvas();
            drawMaze();
            const isPortrait = window.matchMedia("(max-width: 768px) and (orientation: portrait)").matches;
            drawTrace(userTrace, '#e74c3c', isPortrait);
            if (showSolution) drawAnimatedSolution(timestamp, isPortrait);
        }
        
        function clearCanvas() { ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height); }

        function drawMaze(){
            ctx.strokeStyle = '#34495e'; ctx.lineWidth = Math.max(2, cellSize/10); ctx.lineCap = 'round';
            for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
                if(!maze || !maze[r] || !maze[r][c]) continue;
                const x = c * cellSize, y = r * cellSize;
                if (maze[r][c].up) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + cellSize, y); ctx.stroke(); }
                if (maze[r][c].down) { ctx.beginPath(); ctx.moveTo(x, y + cellSize); ctx.lineTo(x + cellSize, y + cellSize); ctx.stroke(); }
                if (maze[r][c].left) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + cellSize); ctx.stroke(); }
                if (maze[r][c].right) { ctx.beginPath(); ctx.moveTo(x + cellSize, y); ctx.lineTo(x + cellSize, y + cellSize); ctx.stroke(); }
            }
            drawStartEndPoints();
        }

        function drawStartEndPoints() {
            const startPos = getCellCenter(start);
            const endPos = getCellCenter(end);
            const radius = cellSize * 0.4;
            
            ctx.font = `bold ${radius}px 'Comic Sans MS'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Draw Start
            ctx.fillStyle = '#28a745';
            ctx.beginPath(); ctx.arc(startPos.x, startPos.y, radius, 0, 2 * Math.PI); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.fillText('Start', startPos.x, startPos.y);

            // Draw End
            ctx.fillStyle = '#dc3545';
            ctx.beginPath(); ctx.arc(endPos.x, endPos.y, radius, 0, 2 * Math.PI); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.fillText('End', endPos.x, endPos.y);
        }

        function drawTrace(trace, color, isPortrait) {
            if (trace.length === 0) return;
            ctx.strokeStyle = color; ctx.lineWidth = Math.max(3, cellSize/8); 
            ctx.lineJoin = 'round'; ctx.lineCap = 'round';
            ctx.beginPath();
            
            let p = getCellCenter(trace[0]);
            if(isPortrait) ctx.moveTo(p.x, 0); else ctx.moveTo(0, p.y);
            
            for (let i = 0; i < trace.length; i++) {
                p = getCellCenter(trace[i]);
                ctx.lineTo(p.x, p.y);
            }

            if (gameWon) {
                p = getCellCenter(end);
                if(isPortrait) ctx.lineTo(p.x, canvas.height); else ctx.lineTo(canvas.width, p.y);
            }
            ctx.stroke();
        }

        function drawAnimatedSolution(timestamp, isPortrait) {
            if (solutionPath.length === 0) return;
            if (solutionAnimationStartTime === null) solutionAnimationStartTime = timestamp;
            let progress = (timestamp - solutionAnimationStartTime) / solutionAnimationDuration;
            if (progress > 1) progress = 1;

            let entryPoint, exitPoint;
            if(isPortrait){
                entryPoint = {x: getCellCenter(start).x, y: 0};
                exitPoint = {x: getCellCenter(end).x, y: canvas.height};
            } else {
                entryPoint = {x: 0, y: getCellCenter(start).y};
                exitPoint = {x: canvas.width, y: getCellCenter(end).y};
            }

            const animatedPath = [ entryPoint, ...solutionPath.map(p => getCellCenter(p)), exitPoint ];
            const segmentsToDraw = (animatedPath.length - 1) * progress;
            ctx.strokeStyle = '#3498db'; ctx.lineWidth = Math.max(3, cellSize / 8); 
            ctx.lineJoin = 'round'; ctx.lineCap = 'round';
            ctx.beginPath(); 
            ctx.moveTo(animatedPath[0].x, animatedPath[0].y);
            for (let i = 0; i < segmentsToDraw; i++) {
                const p1 = animatedPath[Math.floor(i)];
                const p2 = animatedPath[Math.floor(i) + 1];
                if (!p2) continue;
                if (i < Math.floor(segmentsToDraw)) { ctx.lineTo(p2.x, p2.y); } else {
                    const t = i - Math.floor(i);
                    ctx.lineTo(p1.x + (p2.x - p1.x) * t, p1.y + (p2.y - p1.y) * t);
                }
            }
            ctx.stroke();
        }
        
        function handleInteractionStart(e) {
            e.preventDefault();
            if (gameWon) return;
            const pos = getCellFromCoordinates(e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY);
            if (pos && pos.row === start.row && pos.col === start.col) { 
                isDrawing = true; 
                userTrace = [pos];
            }
        }

        function handleInteractionMove(e) {
            if (!isDrawing || gameWon) return;
            e.preventDefault();
            const currentPos = getCellFromCoordinates(e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY);
            if (!currentPos) return;

            let lastPos = userTrace[userTrace.length - 1];
            if (currentPos.row === lastPos.row && currentPos.col === lastPos.col) return;

            // Simple, robust interpolation
            while (lastPos.row !== currentPos.row || lastPos.col !== currentPos.col) {
                const dr = Math.sign(currentPos.row - lastPos.row);
                const dc = Math.sign(currentPos.col - lastPos.col);
                
                let nextPos;
                // Move vertically or horizontally towards the target
                if (Math.abs(currentPos.row - lastPos.row) > Math.abs(currentPos.col - lastPos.col)) {
                    nextPos = { row: lastPos.row + dr, col: lastPos.col };
                } else {
                    nextPos = { row: lastPos.row, col: lastPos.col + dc };
                }

                const moveDr = nextPos.row - lastPos.row;
                const moveDc = nextPos.col - lastPos.col;

                if ((moveDr === 1 && !maze[lastPos.row][lastPos.col].down) || (moveDr === -1 && !maze[lastPos.row][lastPos.col].up) || (moveDc === 1 && !maze[lastPos.row][lastPos.col].right) || (moveDc === -1 && !maze[lastPos.row][lastPos.col].left)) {
                    if (userTrace.length > 1 && nextPos.row === userTrace[userTrace.length - 2].row && nextPos.col === userTrace[userTrace.length - 2].col) {
                        userTrace.pop();
                    } else if (!userTrace.some(p => p.row === nextPos.row && p.col === nextPos.col)) {
                        userTrace.push(nextPos);
                    }
                    
                    if (nextPos.row === end.row && nextPos.col === end.col) {
                        gameWon = true;
                        isDrawing = false;
                        winModal.style.display = 'flex';
                        break;
                    }
                } else {
                    // Hit a wall
                    break;
                }
                lastPos = nextPos;
            }
        }

        function handleInteractionEnd() { isDrawing = false; }

        function generateNewMaze(isPortrait) {
            gameWon = false;
            initMaze(isPortrait);
            generateMazeRecursive(start.row, start.col);
            solutionPath = findSolution();
            userTrace = []; 
            showSolution = false; 
            solutionAnimationStartTime = null;
            document.getElementById('toggleSolution').textContent = 'Solution';
            updateCharacterPositions(isPortrait);
            if (!animationFrameId) mainDrawLoop();
        }

        function getCellFromCoordinates(x, y) {
            const rect = canvas.getBoundingClientRect();
            const col = Math.floor((x - rect.left) / cellSize), row = Math.floor((y - rect.top) / cellSize);
            if (row < 0 || row >= rows || col < 0 || col >= cols) return null;
            return { row, col };
        }

        function getCellCenter(pos) { return { x: (pos.col + 0.5) * cellSize, y: (pos.row + 0.5) * cellSize }; }
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; }
        
        window.addEventListener('resize', resizeAndGenerate);
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mousemove', handleInteractionMove);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        canvas.addEventListener('mouseleave', handleInteractionEnd);
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        
        document.getElementById('generateNew').addEventListener('click', () => resizeAndGenerate());
        document.getElementById('clearTrace').addEventListener('click', () => { if (!gameWon) userTrace = []; });
        document.getElementById('toggleSolution').addEventListener('click', () => { 
            showSolution = !showSolution; 
            document.getElementById('toggleSolution').textContent = showSolution ? 'Hide' : 'Solution'; 
            solutionAnimationStartTime = null; 
            if (!animationFrameId) mainDrawLoop();
            if (showSolution) setTimeout(() => { if (!animationFrameId) { animationFrameId = requestAnimationFrame(mainDrawLoop); setTimeout(()=> {cancelAnimationFrame(animationFrameId); animationFrameId = null;}, solutionAnimationDuration + 200)} }, 20);
        });

        document.getElementById('playAgainBtn').addEventListener('click', () => {
            winModal.style.display = 'none';
            resizeAndGenerate();
        });
        
        document.getElementById('easyBtn').addEventListener('click', () => setDifficulty('easy'));
        document.getElementById('mediumBtn').addEventListener('click', () => setDifficulty('medium'));
        document.getElementById('hardBtn').addEventListener('click', () => setDifficulty('hard'));

        resizeAndGenerate();
    </script>
</body>
</html>
