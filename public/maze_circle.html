<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Circular Maze</title>
    <style>
        body { 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0; 
            background-color: #f0f0f0; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        canvas { 
            border: 5px solid #000; 
            touch-action: none;
        }
        .button-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        button { 
            padding: 10px 20px; 
            font-size: 16px; 
            cursor: pointer; 
            border: none;
            color: white;
            border-radius: 8px;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        button:active {
            transform: translateY(2px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        #toggleSolution { background-color: #3498db; }
        #generateNew { background-color: #2ecc71; }
        #clearTrace { background-color: #e67e22; }
    </style>
</head>
<body>
    <canvas id="mazeCanvas"></canvas>
    <div class="button-container">
        <button id="toggleSolution">Show Solution</button>
        <button id="generateNew">Generate New Maze</button>
        <button id="clearTrace">Clear Trace</button>
    </div>
    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const buttonContainer = document.querySelector('.button-container');

        let width, height, cellSize, centerRadius, mazeAreaRadius;
        const rings = 10;
        const cellsPerRing = 16;
        
        let maze = [];
        let solutionPath = [];
        let userTrace = [];
        
        let start = {};
        let end = {};
        
        let showSolution = false;
        let animationFrameId;
        let animationStartTime = null;
        const animationDuration = 5000;
        let isDrawing = false;

        function resizeCanvas() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            const containerHeight = buttonContainer.offsetHeight;
            const size = Math.min(window.innerWidth * 0.95, (window.innerHeight - containerHeight) * 0.9) - 40;
            canvas.width = size;
            canvas.height = size;
            width = canvas.width;
            height = canvas.height;
            
            centerRadius = (size / 2) * 0.1;
            mazeAreaRadius = (size / 2) - centerRadius;
            cellSize = mazeAreaRadius / rings;

            generateNewMaze();
        }

        function initMaze() {
            maze = Array(rings).fill(null).map(() => Array(cellsPerRing).fill(null).map(() => ({
                inner: true, outer: true, left: true, right: true, visited: false
            })));
            
            start = { ring: rings - 1, cell: Math.floor(Math.random() * cellsPerRing) };
            const entranceCell = Math.floor(Math.random() * cellsPerRing);
            end = { ring: 0, cell: entranceCell };

            maze[start.ring][start.cell].outer = false; // Maze entrance
            maze[end.ring][end.cell].inner = false; // Single entrance to the center
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function generateMazeRecursive(ring, cell) {
            maze[ring][cell].visited = true;
            const directions = shuffle([
                { dr: 0, dc: 1, wall: 'right', oppWall: 'left' },
                { dr: 0, dc: -1, wall: 'left', oppWall: 'right' },
                { dr: -1, dc: 0, wall: 'inner', oppWall: 'outer' },
                { dr: 1, dc: 0, wall: 'outer', oppWall: 'inner' }
            ]);

            for (const { dr, dc, wall, oppWall } of directions) {
                const newRing = ring + dr;
                const newCell = (cell + dc + cellsPerRing) % cellsPerRing;

                if (newRing >= 0 && newRing < rings && !maze[newRing][newCell].visited) {
                    maze[ring][cell][wall] = false;
                    maze[newRing][newCell][oppWall] = false;
                    generateMazeRecursive(newRing, newCell);
                }
            }
        }

        function findSolutionPath() {
            const queue = [{ ...start, path: [start] }];
            const visited = new Set([`${start.ring}-${start.cell}`]);

            while (queue.length > 0) {
                const { ring, cell, path } = queue.shift();

                if (ring === end.ring && cell === end.cell) return path;

                const directions = [
                    { dr: 0, dc: 1, wall: 'right' }, { dr: 0, dc: -1, wall: 'left' },
                    { dr: -1, dc: 0, wall: 'inner' }, { dr: 1, dc: 0, wall: 'outer' }
                ];

                for (const { dr, dc, wall } of directions) {
                    if (!maze[ring][cell][wall]) {
                        const newRing = ring + dr;
                        const newCell = (cell + dc + cellsPerRing) % cellsPerRing;
                        const key = `${newRing}-${newCell}`;

                        if (newRing >= 0 && newRing < rings && !visited.has(key)) {
                            visited.add(key);
                            const newPath = [...path, { ring: newRing, cell: newCell }];
                            queue.push({ ring: newRing, cell: newCell, path: newPath });
                        }
                    }
                }
            }
            return [];
        }
        
        function draw(timestamp) {
            animationFrameId = requestAnimationFrame(draw);
            ctx.clearRect(0, 0, width, height);
            
            const totalRadius = centerRadius + rings * cellSize;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, totalRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.save();
            ctx.translate(width / 2, height / 2);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;
            for (let r = 0; r < rings; r++) {
                for (let c = 0; c < cellsPerRing; c++) {
                    const innerR = centerRadius + r * cellSize;
                    const outerR = centerRadius + (r + 1) * cellSize;
                    const startA = (c / cellsPerRing) * 2 * Math.PI;
                    const endA = ((c + 1) / cellsPerRing) * 2 * Math.PI;

                    if (maze[r][c].inner && r >= 0) { ctx.beginPath(); ctx.arc(0, 0, innerR, startA, endA); ctx.stroke(); }
                    if (maze[r][c].outer) { ctx.beginPath(); ctx.arc(0, 0, outerR, startA, endA); ctx.stroke(); }
                    if (maze[r][c].left) { ctx.beginPath(); ctx.moveTo(innerR * Math.cos(startA), innerR * Math.sin(startA)); ctx.lineTo(outerR * Math.cos(startA), outerR * Math.sin(startA)); ctx.stroke(); }
                }
            }
            
            if (userTrace.length > 0) {
                ctx.strokeStyle = '#6a0dad';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                for (let i = 0; i < userTrace.length; i++) {
                    const pos = getCellCenter(userTrace[i]);
                    if (i === 0) {
                         const startEdgePos = getEdgePos(userTrace[i], 'outer');
                         ctx.moveTo(startEdgePos.x, startEdgePos.y);
                         ctx.lineTo(pos.x, pos.y);
                    } else {
                        ctx.lineTo(pos.x, pos.y);
                    }
                }
                 if(userTrace[userTrace.length - 1].ring === end.ring && userTrace[userTrace.length - 1].cell === end.cell) {
                    const endEdgePos = getEdgePos(end, 'inner');
                    ctx.lineTo(endEdgePos.x, endEdgePos.y);
                }
                ctx.stroke();
            }

            if (showSolution && solutionPath.length > 0) {
                if (animationStartTime === null) animationStartTime = timestamp;
                const progress = Math.min((timestamp - animationStartTime) / animationDuration, 1);
                
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                const pathPoints = solutionPath.map(p => getCellCenter(p));
                const startEdge = getEdgePos(start, 'outer');
                const endEdge = getEdgePos(end, 'inner');
                const fullPath = [startEdge, ...pathPoints, endEdge];

                for(let i = 0; i < fullPath.length - 1; i++) {
                    const t = i / (fullPath.length - 2);
                    if (t <= progress) {
                         ctx.strokeStyle = `hsl(${(t * 360)}, 100%, 50%)`;
                         ctx.beginPath();
                         ctx.moveTo(fullPath[i].x, fullPath[i].y);
                         ctx.lineTo(fullPath[i+1].x, fullPath[i+1].y);
                         ctx.stroke();
                    }
                }
            }

            const startPos = getCellCenter(start);
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath(); ctx.arc(startPos.x, startPos.y, cellSize * 0.4, 0, 2 * Math.PI); ctx.fill();
            
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath(); ctx.arc(0, 0, centerRadius * 0.6, 0, 2 * Math.PI); ctx.fill();

            ctx.restore();
        }

        function getCellFromCoordinates(x, y) {
            const rect = canvas.getBoundingClientRect();
            x -= rect.left + width / 2;
            y -= rect.top + height / 2;
            const radius = Math.sqrt(x * x + y * y);
            if (radius < centerRadius || radius > centerRadius + rings * cellSize) return null;
            const ring = Math.floor((radius - centerRadius) / cellSize);
            const angle = (Math.atan2(y, x) + 2 * Math.PI) % (2 * Math.PI);
            const cell = Math.floor((angle / (2 * Math.PI)) * cellsPerRing);
            return { ring, cell };
        }
        
        function getCellCenter(pos) {
            const radius = centerRadius + (pos.ring + 0.5) * cellSize;
            const angle = ((pos.cell + 0.5) / cellsPerRing) * 2 * Math.PI;
            return { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
        }
        
        function getEdgePos(pos, edge) {
            const radius = edge === 'inner' ? centerRadius + pos.ring * cellSize : centerRadius + (pos.ring + 1) * cellSize;
            const angle = ((pos.cell + 0.5) / cellsPerRing) * 2 * Math.PI;
            return { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
        }

        function handleInteractionStart(e) {
            e.preventDefault();
            const pos = getCellFromCoordinates(e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY);
            if (pos && pos.ring === start.ring && pos.cell === start.cell) {
                isDrawing = true;
                userTrace = [pos];
            }
        }

        function handleInteractionMove(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const pos = getCellFromCoordinates(e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY);
            if (!pos) return;

            const { ring, cell } = pos;
            const lastPos = userTrace[userTrace.length - 1];
            if (ring === lastPos.ring && cell === lastPos.cell) return;

            if (userTrace.length > 1 && ring === userTrace[userTrace.length - 2].ring && cell === userTrace[userTrace.length - 2].cell) {
                userTrace.pop();
                return;
            }

            let moveIsValid = false;
            const dr = ring - lastPos.ring;
            const dc_raw = cell - lastPos.cell;
            const dc = (dc_raw === cellsPerRing - 1) ? -1 : (dc_raw === -(cellsPerRing - 1)) ? 1 : dc_raw;

            if (dr === 0 && Math.abs(dc) === 1) {
                if (dc === 1 && !maze[lastPos.ring][lastPos.cell].right) moveIsValid = true;
                if (dc === -1 && !maze[lastPos.ring][lastPos.cell].left) moveIsValid = true;
            } else if (dc_raw === 0 && Math.abs(dr) === 1) {
                if (dr === -1 && !maze[lastPos.ring][lastPos.cell].inner) moveIsValid = true;
                if (dr === 1 && !maze[lastPos.ring][lastPos.cell].outer) moveIsValid = true;
            }
            
            if (moveIsValid) {
                 userTrace.push({ ring, cell });
                 if (ring === end.ring && cell === end.cell) {
                     setTimeout(() => alert("Awesome! You reached the center!"), 100);
                     isDrawing = false;
                 }
            }
        }

        function handleInteractionEnd() { isDrawing = false; }

        function generateNewMaze() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            initMaze();
            generateMazeRecursive(start.ring, start.cell);
            solutionPath = findSolutionPath();
            userTrace = [];
            showSolution = false;
            animationStartTime = null;
            document.getElementById('toggleSolution').textContent = 'Show Solution';
            animationFrameId = requestAnimationFrame(draw);
        }

        window.addEventListener('resize', resizeCanvas);
        
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mousemove', handleInteractionMove);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        canvas.addEventListener('mouseleave', handleInteractionEnd); 
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        
        document.getElementById('generateNew').addEventListener('click', generateNewMaze);
        document.getElementById('clearTrace').addEventListener('click', () => { 
            if (!isDrawing) userTrace = []; 
        });
        document.getElementById('toggleSolution').addEventListener('click', () => {
            showSolution = !showSolution;
            animationStartTime = null;
            document.getElementById('toggleSolution').textContent = showSolution ? 'Hide Solution' : 'Show Solution';
        });

        resizeCanvas();
    </script>
</body>
</html>