<style>
    #crossword-generator-container {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f0f0f0;
        padding: 20px;
        width: 100%;
        box-sizing: border-box;
        position: relative; /* For message overlay positioning */
    }
    .main-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 40px;
        margin: 20px 0;
    }
    .progress-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    #progress-bar-container {
        width: 30px;
        height: 300px;
        border: 2px solid #333;
        background-color: #e0e0e0;
        display: flex;
        flex-direction: column-reverse; /* To fill from bottom to top */
    }
    #progress-bar {
        width: 100%;
        height: 0%;
        background-color: #4caf50;
        transition: height 0.05s linear; /* Faster transition for visualization */
    }
    #attempt-counter {
        font-size: 1.2em;
        font-family: monospace;
    }
    .crossword-grid {
        display: grid;
        border: 3px solid black;
    }
    .cell {
        border: 1px solid black;
        width: 60px; /* Increased size */
        height: 60px; /* Increased size */
        text-align: center;
        position: relative;
    }
    .cell input {
        width: 100%;
        height: 100%;
        text-align: center;
        border: none;
        font-size: 30px; /* Increased font size */
        background-color: white;
        box-sizing: border-box;
        text-transform: uppercase;
        pointer-events: none; /* Disable manual input */
    }
    .cell.black {
        background-color: black;
    }
    .clue-number {
        position: absolute;
        top: 2px;
        left: 2px;
        font-size: 12px;
    }
    .json-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 500px;
    }
    #json-output {
        width: 100%;
        height: 300px;
        white-space: pre;
        font-family: monospace;
    }
    .back-link {
        margin-top: 20px;
        font-size: 1.2em;
    }
    .message-overlay {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 30px;
        border-radius: 8px;
        color: white;
        font-size: 1.5em;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.5s, top 0.5s;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        pointer-events: none;
    }
    .message-overlay.show {
        opacity: 1;
        top: 30px;
    }
    .message-overlay.error {
        background-color: #D32F2F; /* A strong red */
    }
    .message-overlay.success {
        background-color: #388E3C; /* A rich green */
    }
    .message-overlay.info {
        background-color: #673AB7; /* Purple for info */
    }
</style>

<section class="stage">
<div id="crossword-generator-container">
    <h1>4x4 Crossword Puzzle Generator</h1>
    <div class="main-container">
        <div class="progress-container">
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>
            <div id="attempt-counter">0 / 20000</div>
        </div>
        <div class="crossword-grid" id="crossword-grid"></div>
        <div class="json-container">
            <button id="generate-json" disabled>Generate JSON</button>
            <button id="copy-to-clipboard">Copy to Clipboard</button>
            <textarea id="json-output" readonly></textarea>
        </div>
    </div>
    <button id="generate-crossword">Generate Crossword</button>
    <a href="index_crossword.html" class="back-link">Back to Crossword Index</a>
</div>
</section>

<script src="crossword_words_letters3.js"></script>
<script src="crossword_words_letters4.js"></script>
<script>
    (() => {
        const container = document.getElementById('crossword-generator-container');
        if (!container) return;

        const gridElement = container.querySelector('#crossword-grid');
        const generateJsonButton = container.querySelector('#generate-json');
        const copyToClipboardButton = container.querySelector('#copy-to-clipboard');
        const generateCrosswordButton = container.querySelector('#generate-crossword');
        const jsonOutput = container.querySelector('#json-output');
        const progressBar = container.querySelector('#progress-bar');
        const attemptCounter = container.querySelector('#attempt-counter');

        let currentDisplayGrid = [];
        let lastAttemptedGrid = null;
        let solvedGrid = null;
        const size = 4;
        const maxTotalAttempts = 20000;
        let totalAttempts = 0;

        const layouts = [
            { name: "Fully Open (8 words)", cells: [] },
            { name: "Your Suggestion (6 words)", cells: [[1,1],[1,2],[3,1],[3,2]] },
            { name: "Forced 3-Letter (6 words)", cells: [[0,1],[1,1],[1,3],[2,0],[2,2],[3,2]]},
            { name: "Diagonal Top-Left (6 words)", cells: [[1, 1], [2, 2]] },
            { name: "Diagonal Top-Right (6 words)", cells: [[1, 2], [2, 1]] },
            { name: "Open Frame (4 words)", cells: [[0, 0], [0, 3], [3, 0], [3, 3]] },
            { name: "High-Quality Intersecting (4 words)", cells: [[1, 1], [1, 2], [2, 1], [2, 2]] }
        ];

        if (typeof words3 === 'undefined' || typeof words4 === 'undefined') {
            console.error("Word banks (words3 or words4) are not loaded.");
            return;
        }

        // ** CORRECTED: Combine word banks in memory **
        const combinedWords = words4.concat(words3);

        const wordBank = combinedWords.map(w => ({ word: w.word.toUpperCase(), clue: w.clue }));

        if (wordBank.length < 4) {
            console.error("Not enough 3 or 4-letter words found.");
            return;
        }
        
        const prefixSet = new Set();
        wordBank.forEach(w => {
            for (let i = 1; i <= w.word.length; i++) {
                prefixSet.add(w.word.substring(0, i));
            }
        });

        function getClueForWord(wordString) {
            const wordObj = wordBank.find(w => w.word === wordString);
            return wordObj ? wordObj.clue : "";
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function showMessage(message, type = 'info', duration = 2500) {
            return new Promise(resolve => {
                const messageDiv = document.createElement('div');
                messageDiv.textContent = message;
                messageDiv.classList.add('message-overlay', type);
                document.body.appendChild(messageDiv);

                setTimeout(() => {
                    messageDiv.classList.add('show');
                }, 10);

                setTimeout(() => {
                    messageDiv.classList.remove('show');
                    setTimeout(() => {
                        if (document.body.contains(messageDiv)) {
                            document.body.removeChild(messageDiv);
                        }
                        resolve();
                    }, 500);
                }, duration);
            });
        }

        function createGridModel(blackCellPositions = []) {
            const model = Array.from({ length: size }, () =>
                Array.from({ length: size }, () => ({ letter: '', black: false }))
            );
            blackCellPositions.forEach(([r, c]) => {
                if (r >= 0 && r < size && c >= 0 && c < size) {
                    model[r][c].black = true;
                }
            });
            return model;
        }

        function renderGrid(gridToRender) {
            currentDisplayGrid = gridToRender;
            gridElement.innerHTML = '';
            gridElement.style.gridTemplateColumns = `repeat(${size}, 60px)`;
            gridElement.style.gridTemplateRows = `repeat(${size}, 60px)`;
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    const input = document.createElement('input');
                    input.maxLength = 1;
                    input.id = `cell-${r}-${c}`;
                    const cellData = gridToRender[r][c];
                    if (cellData.black) {
                        cell.classList.add('black');
                    } else {
                        input.value = cellData.letter;
                    }
                    cell.appendChild(input);
                    gridElement.appendChild(cell);
                }
            }
        }
        
        function flashLetters(gridToFlash) {
             for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const input = gridElement.querySelector(`#cell-${r}-${c}`);
                    const cellData = gridToFlash[r][c];
                    if (input && !cellData.black) {
                        input.value = cellData.letter;
                    }
                }
            }
        }

        async function generateAndFillCrossword() {
            generateCrosswordButton.disabled = true;
            generateJsonButton.removeEventListener('click', copyFailState);
            generateJsonButton.addEventListener('click', generateJson);
            generateJsonButton.textContent = 'Generate JSON';
            generateJsonButton.disabled = true;
            jsonOutput.value = '';
            solvedGrid = null;
            totalAttempts = 0;
            progressBar.style.height = '0%';
            progressBar.style.backgroundColor = '#4caf50';
            attemptCounter.textContent = `0 / ${maxTotalAttempts}`;
            
            let finalSolution = null;

            for (const layout of layouts) {
                const gridModel = createGridModel(layout.cells);
                renderGrid(gridModel); 
                await showMessage(`Trying layout: ${layout.name}`, 'info', 1500);
                
                finalSolution = await solve(gridModel);
                if (finalSolution) break;
                 if (totalAttempts >= maxTotalAttempts) {
                    await showMessage(`Max total attempts reached. Stopping.`, 'error');
                    break;
                }
            }

            if (finalSolution) {
                solvedGrid = finalSolution;
                renderGrid(solvedGrid); 
                await showMessage('Crossword generated successfully!', 'success', 4000);
                generateJsonButton.disabled = false;
            } else {
                progressBar.style.height = '100%';
                progressBar.style.backgroundColor = '#f44336';
                attemptCounter.textContent = `Failed / ${totalAttempts}`;
                await showMessage(`Could not generate a crossword after ${totalAttempts} attempts.`, 'error', 4000);
                renderGrid(lastAttemptedGrid || createGridModel(layouts[0].cells));
                
                generateJsonButton.textContent = 'Copy Fail State';
                generateJsonButton.disabled = false;
                generateJsonButton.removeEventListener('click', generateJson);
                generateJsonButton.addEventListener('click', copyFailState);
            }

            generateCrosswordButton.disabled = false;
        }
        
        function copyFailState() {
            if (!lastAttemptedGrid) {
                 showMessage('No fail state to copy.', 'error');
                 return;
            }
             const failStateString = JSON.stringify(lastAttemptedGrid.map(row => row.map(cell => cell.letter || (cell.black ? 'X' : '.'))), null, 2);
            jsonOutput.value = `// Last failed attempt:
${failStateString}`;
            copyToClipboard();
        }

        function isGridStillValid(grid) {
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (!grid[r][c].black && (c === 0 || grid[r][c - 1].black)) {
                        let partialWord = '';
                        let hasLetters = false;
                        for (let k = c; k < size && !grid[r][k].black; k++) {
                            if (grid[r][k].letter) {
                                partialWord += grid[r][k].letter;
                                hasLetters = true;
                            } else {
                                break;
                            }
                        }
                        if (hasLetters && !prefixSet.has(partialWord)) return false;
                    }
                }
            }

            for (let c = 0; c < size; c++) {
                for (let r = 0; r < size; r++) {
                    if (!grid[r][c].black && (r === 0 || grid[r - 1][c].black)) {
                        let partialWord = '';
                        let hasLetters = false;
                        for (let k = r; k < size && !grid[k][c].black; k++) {
                            if (grid[k][c].letter) {
                                partialWord += grid[k][c].letter;
                                hasLetters = true;
                            } else {
                                break;
                            }
                        }
                        if (hasLetters && !prefixSet.has(partialWord)) return false;
                    }
                }
            }
            return true;
        }
        
        // ** REWRITTEN SOLVER BASED ON YOUR "MOST-CONSTRAINED-SLOT-FIRST" STRATEGY **
        async function solve(initialGrid) {
            const shuffledWords = [...wordBank].sort(() => 0.5 - Math.random());
            let layoutAttempts = 0;
            const maxAttemptsPerLayout = 5000;

            async function backtrack(currentGrid, usedWords) {
                lastAttemptedGrid = currentGrid;
                if (totalAttempts >= maxTotalAttempts || layoutAttempts >= maxAttemptsPerLayout) return null;

                const unfilledSlots = getUnfilledSlots(currentGrid);
                if (unfilledSlots.length === 0) return currentGrid;

                // Calculate constraints and sort
                unfilledSlots.forEach(slot => {
                    const pattern = getPattern(currentGrid, slot);
                    slot.constraint = getPossibleWords(pattern, shuffledWords, usedWords).length;
                });
                unfilledSlots.sort((a, b) => a.constraint - b.constraint);

                const slotToFill = unfilledSlots[0];
                const pattern = getPattern(currentGrid, slotToFill);
                const possibleWords = getPossibleWords(pattern, shuffledWords, usedWords);

                for (const wordObj of possibleWords) {
                    totalAttempts++;
                    layoutAttempts++;
                    const newGrid = placeWord(currentGrid, wordObj.word, slotToFill);

                    if (!isGridStillValid(newGrid)) {
                        continue;
                    }
                    
                    if (totalAttempts % 5 === 0) { // Update UI less frequently for speed
                        flashLetters(newGrid);
                        const progress = (totalAttempts / maxTotalAttempts) * 100;
                        progressBar.style.height = `${Math.min(100, progress)}%`;
                        attemptCounter.textContent = `${totalAttempts} / ${maxTotalAttempts}`;
                        await sleep(1); 
                    }

                    const newUsedWords = [...usedWords, wordObj.word];
                    const result = await backtrack(newGrid, newUsedWords);
                    if (result) return result;
                }

                return null;
            }

            return await backtrack(initialGrid, []);
        }

        function getUnfilledSlots(grid) {
            const allSlots = getWordSlots(grid);
            return allSlots.filter(slot => {
                const pattern = getPattern(grid, slot);
                return pattern.includes('.');
            });
        }

        function getWordSlots(targetGrid) {
            const slots = [];
            // Across
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (!targetGrid[r][c].black && (c === 0 || targetGrid[r][c - 1].black)) {
                        let length = 0;
                        while (c + length < size && !targetGrid[r][c + length].black) length++;
                        if (length > 1) slots.push({ row: r, col: c, length, direction: 'across' });
                    }
                }
            }
            // Down
            for (let c = 0; c < size; c++) {
                for (let r = 0; r < size; r++) {
                    if (!targetGrid[r][c].black && (r === 0 || targetGrid[r - 1][c].black)) {
                        let length = 0;
                        while (r + length < size && !targetGrid[r + length][c].black) length++;
                        if (length > 1) slots.push({ row: r, col: c, length, direction: 'down' });
                    }
                }
            }
            return slots;
        }

        function getPattern(grid, slot) {
            let pattern = '';
            if (slot.direction === 'across') {
                for (let i = 0; i < slot.length; i++) pattern += grid[slot.row][slot.col + i].letter || '.';
            } else {
                for (let i = 0; i < slot.length; i++) pattern += grid[slot.row + i][slot.col].letter || '.';
            }
            return pattern;
        }

        function getPossibleWords(pattern, words, usedWords = []) {
            if (pattern.length < 2) return [];
            const regex = new RegExp('^' + pattern + '$');
            return words.filter(w =>
                w.word.length === pattern.length &&
                regex.test(w.word) &&
                !usedWords.includes(w.word)
            );
        }

        function placeWord(grid, word, slot) {
            const newGrid = JSON.parse(JSON.stringify(grid));
            if (slot.direction === 'across') {
                for (let i = 0; i < word.length; i++) newGrid[slot.row][slot.col + i].letter = word[i];
            } else {
                for (let i = 0; i < word.length; i++) newGrid[slot.row + i][slot.col].letter = word[i];
            }
            return newGrid;
        }

        function generateJson() {
            if (!solvedGrid) {
                jsonOutput.value = "Grid is not solved. No JSON to generate.";
                return;
            }

            const finalWords = [];
            let clueNumber = 1;
            const wordStarts = new Map();
            const slots = getWordSlots(solvedGrid);
            const numberedPositions = new Set();

            container.querySelectorAll('.clue-number').forEach(num => num.remove());

            // Number the grid cells
            for (const slot of slots) {
                const pos = `${slot.row}-${slot.col}`;
                if (!numberedPositions.has(pos)) {
                    const cellElement = gridElement.querySelector(`#cell-${slot.row}-${slot.col}`).parentElement;
                    if (cellElement) {
                        const clueNumberDiv = document.createElement('div');
                        clueNumberDiv.classList.add('clue-number');
                        clueNumberDiv.textContent = clueNumber;
                        cellElement.appendChild(clueNumberDiv);
                        wordStarts.set(pos, clueNumber);
                        numberedPositions.add(pos);
                        clueNumber++;
                    }
                }
            }

            slots.forEach(slot => {
                let word = '';
                if (slot.direction === 'across') {
                    for (let i = 0; i < slot.length; i++) word += solvedGrid[slot.row][slot.col + i].letter;
                } else {
                    for (let i = 0; i < slot.length; i++) word += solvedGrid[slot.row + i][slot.col].letter;
                }

                if (word.length > 1) {
                    finalWords.push({ word: word, clue: getClueForWord(word), row: slot.row, col: slot.col, direction: slot.direction });
                }
            });

            let outputString = `level: 12,
size: ${size},
words: [
`;
            finalWords.forEach(word => {
                // ** CORRECTED: Safely escape single quotes for the JSON string **
                const clue = word.clue ? word.clue.replace(/'/g, "\'") : "";
                outputString += `    { word: "${word.word}", clue: '${clue}', row: ${word.row}, col: ${word.col}, direction: "${word.direction}" },
`;
            });
            outputString += `]`;

            jsonOutput.value = outputString;
        }

        function copyToClipboard() {
            if (!jsonOutput.value || jsonOutput.value === "Grid is empty. Generation failed.") {
                showMessage('Nothing to copy yet!', 'error');
                return;
            }
            jsonOutput.select();
            document.execCommand('copy');
            showMessage('Copied to clipboard!', 'success');
        }
        
        generateCrosswordButton.addEventListener('click', generateAndFillCrossword);
        generateJsonButton.addEventListener('click', generateJson);
        copyToClipboardButton.addEventListener('click', copyToClipboard);
        
        const initialGridModel = createGridModel(layouts[0].cells);
        renderGrid(initialGridModel);

    })();
</script>