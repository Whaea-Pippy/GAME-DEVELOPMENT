<!DOCTYPE html>
<!--Created by Priscilla Allan with help from Grok, ChatGPT, and a little Gemini-->
<!--I am learning HTML, Java script & how to harness FREE ai-coding help-->
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Mots Mêlés - French Word Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        :root{ --tile-bg: rgba(255,255,255,0.2); }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f74ff7 0%, #f53da8 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #fff;
            padding: 20px;
            touch-action: none;
            overflow-y: auto;
            transition: background 600ms ease;
        }
        .container {
            background-color: rgba(255, 255, 255, 0.09);
            border-radius: 24px;
            padding: 18px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 980px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 1rem;
        }
        .title {
            font-size: 2.25rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.35);
        }
        .score {
            font-size: 1.25rem;
            font-weight: 700;
            color: #fff;
            background: rgba(0,0,0,0.28);
            padding: 8px 16px;
            border-radius: 9999px;
        }
        .instructions-btn {
            background: rgba(0,0,0,0.28);
            color: #fff;
            padding: 8px 16px;
            border-radius: 9999px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.15s;
            border: none;
        }
        .instructions-btn:hover {
            transform: translateY(-3px);
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: #fff;
            color: #000;
            padding: 20px;
            border-radius: 12px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .modal-content h2, .modal-content h3 {
            font-weight: 700;
        }
        .modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #e5e7eb;
            color: #000;
            padding: 8px 12px;
            border-radius: 9999px;
            cursor: pointer;
            font-weight: 700;
            border: none;
        }
        .progress-bar {
            display: flex;
            gap: 4px;
            margin-bottom: 1rem;
            width: 100%;
            justify-content: center;
        }
        .progress-square {
            width: 30px;
            height: 30px;
            background: #ffffff;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 700;
            color: #000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background 0.3s;
        }
        .level-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }
        .level-indicator {
            font-weight: 700;
            padding: 6px 10px;
            border-radius: 9999px;
            background: rgba(255,255,255,0.12);
        }
        .main-content {
            display: flex;
            width: 100%;
            gap: 18px;
            flex-direction: column;
        }
        @media(min-width:768px) {
            .main-content {
                flex-direction: row;
                align-items: flex-start;
            }
        }
        .game-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .word-builder {
            display: flex;
            justify-content: center;
            min-height: 48px;
            gap: 6px;
            margin-bottom: 12px;
            background-color: rgba(255, 255, 255, 0.14);
            border-radius: 12px;
            padding: 8px;
            width: 100%;
            text-transform: uppercase;
        }
        .built-letter {
            width: 34px;
            height: 34px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #fff;
            color: #000;
            font-weight: 700;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            animation: popIn 0.18s ease;
        }
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0 }
            100% { transform: scale(1); opacity: 1 }
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            width: 100%;
            max-width: 520px;
            aspect-ratio: 6 / 5;
            margin-bottom: 12px;
            position: relative;
        }
        .tile {
            position: relative;
            background-color: var(--tile-bg);
            color: black;
            font-size: clamp(0.9rem, 3.5vw, 1.6rem);
            font-weight: 700;
            border-radius: 12px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.18s, box-shadow 0.18s, opacity 0.25s, top 0.35s ease-out;
            text-transform: uppercase;
            box-shadow: 0 4px 8px rgba(0,0,0,0.12);
        }
        .tile.hidden-tile {
            opacity: 0;
        }
        .tile:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.16);
        }
        .selected {
            transform: scale(1.06);
            outline: 3px solid white;
            outline-offset: -4px;
        }
        .message-box {
            background-color: rgba(0,0,0,0.32);
            color: white;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
            font-weight: 700;
            width: 100%;
        }
        .win-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0,0,0,0.3);
            z-index: 10;
        }
        .win-star {
            width: 60%;
            height: 60%;
            background-color: rgba(255,255,255,0.2);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .win-text {
            font-size: 2.5rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.5);
            margin-top: 16px;
        }
        .win-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }
        .win-button {
            background-color: rgba(0,0,0,0.28);
            color: white;
            padding: 8px 16px;
            border-radius: 9999px;
            font-weight: 700;
            transition: transform 0.15s;
            border: none;
        }
        .win-button:hover {
            transform: translateY(-3px);
        }
        .word-list-section {
            width: 320px;
            min-width: 240px;
            max-width: 340px;
            background-color: rgba(0,0,0,0.14);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        .word-list-heading {
            font-size: 1.05rem;
            font-weight: 700;
            margin-bottom: 8px;
        }
        .word-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .word-item {
            border-radius: 8px;
            padding: 6px 8px;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .word-item-text {
            font-size: 1.05rem;
            font-weight: 800;
        }
        .word-item-count {
            font-size: 1rem;
            font-weight: 700;
        }
        .tick {
            font-size: 1.2rem;
            margin-left: 6px;
        }
        .star-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8.4px;
            margin-top: 12px;
            width: 100%;
            max-width: 240px;
            justify-content: center;
            margin-left: auto;
            margin-right: auto;
        }
        .star {
            width: 32px;
            height: 32px;
            background-color: #ffffff;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            cursor: pointer;
            transition: transform 0.18s, background-color 0.18s;
            transform: scale(2);
        }
        .star.used {
            background-color: #9ca3af;
            transform: scale(1);
            cursor: default;
        }
        .controls-row {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }
        button {
            background-color: rgba(0,0,0,0.28);
            color: white;
            padding: 8px 14px;
            border-radius: 9999px;
            font-weight: 700;
            transition: transform 0.15s;
            border: none;
        }
        button:hover {
            transform: translateY(-3px);
        }
.audit-trail-section {
width: 100%;
background-color: rgba(0,0,0,0.14);
border-radius: 12px;
padding: 12px;
display: flex;
flex-direction: column;
align-items: stretch;
margin: 18px auto 0; /* Center horizontally and add top margin */
}
.audit-trail-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 8px;
}
        .bg-level-1 { background: linear-gradient(135deg, #EFDDF8 0%, #9ca3af 100%); }
        .bg-level-2 { background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%); }
        .bg-level-3 { background: linear-gradient(135deg, #06b6d4 0%, #7dd3fc 100%); }
        .bg-level-4 { background: linear-gradient(135deg, #22c55e 0%, #86efac 100%); }
        .bg-level-5 { background: linear-gradient(135deg, #16a34a 0%, #4ade80 100%); }
        .bg-level-6 { background: linear-gradient(135deg, #facc15 0%, #fef08a 100%); }
        .bg-level-7 { background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%); }
        .bg-level-8 { background: linear-gradient(135deg, #fb923c 0%, #f97316 100%); }
        .bg-level-9 { background: linear-gradient(135deg, #f97316 0%, #fb923c 100%); }
        .bg-level-10 { background: linear-gradient(135deg, #ef4444 0%, #f87171 100%); }
        .bg-level-11 { background: linear-gradient(135deg, #b91c1c 0%, #ef4444 100%); }
        .bg-level-12 { background: linear-gradient(135deg, #ec4899 0%, #f472b6 100%); }
        .bg-level-13 { background: linear-gradient(135deg, #db2777 0%, #ec4899 100%); }
        .bg-level-14 { background: linear-gradient(135deg, #a855f7 0%, #c084fc 100%); }
        .bg-level-15 { background: linear-gradient(135deg, #7e22ce 0%, #a78bfa 100%); }
        .bg-level-16 { background: linear-gradient(135deg, #ff0000 0%, #ff7f00 100%); }
        .bg-level-17 { background: linear-gradient(135deg, #ff7f00 0%, #ffff00 100%); }
        .bg-level-18 { background: linear-gradient(135deg, #ff0000 0%, #ff7f00 50%, #ffff00 100%); }
        .bg-level-19 { background: linear-gradient(135deg, #ff0000 0%, #ff7f00 33%, #ffff00 66%, #00ff00 100%); }
        .bg-level-20 { background: linear-gradient(135deg, #ff0000 0%, #ff7f00 20%, #ffff00 40%, #00ff00 60%, #0000ff 80%, #4b0082 100%); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="instructions-btn" id="instructions-btn">Instructions</button>
            <h1 class="title">Mots Mêlés</h1>
            <div class="score" id="score-display">Score: 0</div>
        </div>
        <div class="progress-bar" id="progress-bar"></div>
        <div class="level-controls">
            <div class="controls-row">
                <button id="prev-level">◀ Prev</button>
                <div class="level-indicator" id="level-indicator">Level 1 / 20</div>
                <button id="next-level">Next ▶</button>
            </div>
        </div>
        <div class="main-content">
            <div id="game-container" class="game-section">
                <div id="word-builder" class="word-builder"></div>
                <div id="grid-container" class="grid"></div>
                <div id="message-box" class="message-box opacity-0 transition-opacity duration-300"></div>
                <div id="win-screen" class="hidden"></div>
            </div>
            <div class="word-list-section">
                <div class="word-list-heading">Words to find</div>
                <div id="word-list" class="word-list"></div>
                <div class="star-container" id="star-container"></div>
            </div>
        </div>
    </div>
    <div class="modal" id="instructions-modal">
        <div class="modal-content">
            <button class="modal-close" id="modal-close">Close</button>
            <h2>How to Play Rapu Kupu</h2>
            <p>Find and connect letters to form the hidden words.</p>
            <p>Words SNAKE up, down, left, right, or diagonally.</p>
            <p> SELECT letters in order to form words.</p>
            <h3>Scoring</h3>
            <p>+1 point for each letter in the main word list.</p>
            <p>+5 points for each letter in bonus words.</p>
            <p>Bonus words can come from any level or the bonus word bank, not just the current level.</p>
            <h3>Stars</h3>
            <p>Stars can be clicked when you get stuck to reset the board.</p>
            <h3>Progress Bar</h3>
            <p>The progress bar at the top shows your progress through the levels.</p>
            <h3>Tips</h3>
            <p>Look carefully — bonus words can sneak through the purple filler letters!</p>
            <p>The later levels get more colourful and challenging.</p>
            <h2>Copy the learning log</h2>
            <h3>Copy then paste as an EMBED into your google site</h3>
        </div>
    </div>
</div>
<div class="audit-trail-section">
    <button id="copy-trail" class="win-button" onclick="copyToClipboard()">
        Rapu Kupu: Learning Log 2025         [CC BY-NC]        Click to COPY
    </button>
    <div id="learning-log-list" class="word-list"></div>
</div>

    <script>
const messageBox = document.getElementById('message-box');
    document.addEventListener('DOMContentLoaded', () => {
        const gridContainer = document.getElementById('grid-container');
        const messageBox = document.getElementById('message-box');
        const winScreen = document.getElementById('win-screen');
        const gameContainer = document.getElementById('game-container');
        const wordListEl = document.getElementById('word-list');
        const wordBuilderEl = document.getElementById('word-builder');
        const starContainer = document.getElementById('star-container');
        const prevLevelBtn = document.getElementById('prev-level');
        const nextLevelBtn = document.getElementById('next-level');
        const levelIndicator = document.getElementById('level-indicator');
        const progressBar = document.getElementById('progress-bar');
        const scoreDisplay = document.getElementById('score-display');
        const instructionsBtn = document.getElementById('instructions-btn');
        const instructionsModal = document.getElementById('instructions-modal');
        const modalClose = document.getElementById('modal-close');
        const learningLogList = document.getElementById('learning-log-list');
        const copyTrailBtn = document.getElementById('copy-trail');

        const GRID_SIZE = 6;
        const FIND_COUNT_PER_WORD = 1;
        const TOTAL_STARS = 15;

        let gameBoard = [];
        let selectedTiles = [];
        let foundWordCounts = {};
        let wordPlacementCounts = {};
        let wordsToFind = [];
        let wordInfo = {};
        let isDragging = false;
        let lastTile = null;
        let stars = [];
        let starsUsedCount = 0;
        let completedLevels = new Set();
        let score = 0;
        let foundWordsTrail = [];
        let normalizedTranslations = {};
        let selectionStartTime = null; // To track time taken for word selection

        const letters = ['a', 'e', 'h', 'i', 'k', 'm', 'n', 'o', 'p', 'r', 't', 'u', 'w'];

        const BONUS_WORDS = [
{ w: 'école', t: 'school' },
{ w: 'livre', t: 'book' },
{ w: 'stylo', t: 'pen' },
{ w: 'tableau', t: 'whiteboard' },
{ w: 'professeur', t: 'teacher' },
{ w: 'élève', t: 'student' },
{ w: 'enfants', t: 'children' },
{ w: 'ami', t: 'friend' },

{ w: 'maison', t: 'house' },
{ w: 'chaise', t: 'chair' },
{ w: 'photo', t: 'picture/photo' },
{ w: 'fenêtre', t: 'window' },
{ w: 'porte', t: 'door' },
{ w: 'lit', t: 'bed' },
{ w: 'tapis', t: 'mat' },
{ w: 'lin', t: 'flax' },

{ w: 'nourriture', t: 'food' },
{ w: 'eau', t: 'water' },
{ w: 'boisson', t: 'drink' },
{ w: 'lait', t: 'milk' },
{ w: 'pêche', t: 'peach' },
{ w: 'orange', t: 'orange' },
{ w: 'cacahuète', t: 'peanut' },
{ w: 'maïs', t: 'corn' },
{ w: 'patate douce', t: 'sweet potato' },
{ w: 'poisson', t: 'fish' },
{ w: 'œuf', t: 'egg' },

{ w: 'travail', t: 'work' },
{ w: 'écouter', t: 'listen' },
{ w: 'lire', t: 'read/announcement' },
{ w: 'écrire', t: 'write' },
{ w: 'laver', t: 'wash/clean' },
{ w: 'rire', t: 'laugh' },
{ w: 'aller', t: 'go' },
{ w: 'asseoir', t: 'sit/stay' },
{ w: 'courir', t: 'run' },
{ w: 'parler', t: 'speak' },

{ w: 'famille', t: 'family' },
{ w: 'maman', t: 'mum' },
{ w: 'papa', t: 'dad' },
{ w: 'soeur', t: 'sister' },
{ w: 'frère', t: 'brother' },
{ w: 'aîné', t: 'older sibling' },
{ w: 'cadet', t: 'younger sibling' },
{ w: 'grand-père', t: 'grandfather' },
{ w: 'grand-mère', t: 'grandmother' },
{ w: 'nièce/neveu', t: 'niece/nephew' },

{ w: 'dieu', t: 'god' },
{ w: 'déesse du feu', t: 'Goddess of fire' },
{ w: 'déesse de la mer', t: 'Goddess of the ocean' },
{ w: 'dieu du vent', t: 'God of wind' },
{ w: 'déesse du tissage', t: 'Goddess of weaving/childbirth' },
{ w: 'dieu étoile', t: 'Star god of kindness' },
{ w: 'terre', t: 'Earth mother' },
{ w: 'ciel', t: 'Sky father' },
{ w: 'héros', t: 'legendary hero' },

{ w: 'couleur', t: 'colour' },
{ w: 'rouge', t: 'red' },
{ w: 'vert', t: 'green' },
{ w: 'bleu', t: 'blue' },
{ w: 'blanc', t: 'white' },
{ w: 'noir', t: 'black' },
{ w: 'jaune', t: 'yellow' },
{ w: 'brun', t: 'brown' },
{ w: 'gris', t: 'grey' },
{ w: 'or', t: 'gold' },
{ w: 'argent', t: 'silver' },

{ w: 'forêt', t: 'forest' },
{ w: 'mer', t: 'sea' },
{ w: 'montagne', t: 'mountain' },
{ w: 'rivière', t: 'river' },
{ w: 'lac', t: 'lake' },
{ w: 'sable', t: 'sand' },
{ w: 'vague', t: 'wave' },
{ w: 'terre', t: 'land' },
{ w: 'arbre', t: 'tree' },
{ w: 'oiseau', t: 'bird' },
{ w: 'insecte', t: 'insect/reptile' },
{ w: 'baleine', t: 'whale' },
{ w: 'homard', t: 'crayfish' },

{ w: 'temps', t: 'time' },
{ w: 'jour/soleil', t: 'day/sun' },
{ w: 'nuit', t: 'night' },
{ w: 'semaine', t: 'week' },
{ w: 'mois/lune', t: 'month/moon' },
{ w: 'année', t: 'year' },
{ w: 'lundi', t: 'monday' },
{ w: 'mardi', t: 'tuesday' },
{ w: 'mercredi', t: 'wednesday' },
{ w: 'jeudi', t: 'thursday' },
{ w: 'vendredi', t: 'friday' },
{ w: 'samedi', t: 'saturday' },
{ w: 'dimanche', t: 'sunday' },
{ w: 'danse', t: 'haka/dance' },
];


const LEVELS = [
  {
    name: 'Salle de Classe',
    bg: 'linear-gradient(135deg,#b7ecf0 0%, #abc8f9 100%)',
    wordColors: ['#e5e7eb', '#d1d5db', '#9ca3af', '#6b7280', '#4b5563'],
    words: [
      { w: 'enseignant', t: 'teacher', c: 'bg-[#6b7280] text-white' },
      { w: 'étudiant', t: 'student', c: 'bg-[#9ca3af] text-black' },
      { w: 'enfants', t: 'children', c: 'bg-[#d1d5db] text-black' },
      { w: 'parler', t: 'speak', c: 'bg-[#e5e7eb] text-black' },
      { w: 'classe', t: 'classroom', c: 'bg-[#4b5563] text-white' }
    ]
  },
  {
    name: 'Famille',
    bg: 'linear-gradient(135deg,#3b82f6 0%, #60a5fa 100%)',
    wordColors: ['#93c5fd', '#60a5fa', '#3b82f6', '#2563eb', '#1e40af'],
    words: [
      { w: 'grandmere', t: 'grandmother', c: 'bg-[#1e40af] text-white' },
      { w: 'ancetre', t: 'ancestors', c: 'bg-[#2563eb] text-white' },
      { w: 'famille', t: 'family', c: 'bg-[#3b82f6] text-white' },
      { w: 'maman', t: 'mum', c: 'bg-[#60a5fa] text-black' },
      { w: 'papa', t: 'dad', c: 'bg-[#93c5fd] text-black' }
    ]
  },
  {
    name: 'Forêt & Mer',
    bg: 'linear-gradient(135deg,#06b6d4 0%, #7dd3fc 100%)',
    wordColors: ['#1e3a8a', '#1e40af', '#3b82f6', '#fef08a', '#facc15'],
    words: [
      { w: 'coquille', t: 'shell', c: 'bg-[#fef08a] text-black' },
      { w: 'oiseau', t: 'bird', c: 'bg-[#1e3a8a] text-white' },
      { w: 'forêt', t: 'forest', c: 'bg-[#1e40af] text-white' },
      { w: 'arbre', t: 'tree', c: 'bg-[#3b82f6] text-white' },
      { w: 'mer', t: 'sea', c: 'bg-[#facc15] text-black' }
    ]
  },
  {
    name: 'Vêtements',
    bg: 'linear-gradient(135deg,#22c55e 0%, #86efac 100%)',
    wordColors: ['#1e3a8a', '#1e40af', '#3b82f6', '#fef08a', '#facc15'],
    words: [
      { w: 'chaussure', t: 'shoe', c: 'bg-[#1e3a8a] text-white' },
      { w: 'pantalon', t: 'trousers', c: 'bg-[#3b82f6] text-white' },
      { w: 'chapeau', t: 'hat', c: 'bg-[#1e40af] text-white' },
      { w: 'jupe', t: 'skirt', c: 'bg-[#fef08a] text-black' },
      { w: 'robe', t: 'dress', c: 'bg-[#facc15] text-black' }
    ]
  },
  {
    name: 'Mythes et Légendes',
    bg: 'linear-gradient(135deg,#16a34a 0%, #4ade80 100%)',
    wordColors: ['#1e3a8a', '#1e40af', '#3b82f6', '#fef08a', '#facc15'],
    words: [
      { w: 'legendes', t: 'legends', c: 'bg-[#1e40af] text-white' },
      { w: 'sorcier', t: 'wizard', c: 'bg-[#3b82f6] text-white' },
      { w: 'dragon', t: 'dragon', c: 'bg-[#1e3a8a] text-white' },
      { w: 'héros', t: 'hero', c: 'bg-[#fef08a] text-black' },
      { w: 'sage', t: 'sage', c: 'bg-[#facc15] text-black' }
    ]
  },
  {
    name: 'Couleurs',
    bg: 'linear-gradient(135deg,#facc15 0%, #fef08a 100%)',
    wordColors: ['#fef08a', '#8b4513', '#f97316', '#16a34a', '#111827'],
    words: [
      { w: 'marron', t: 'brown', c: 'bg-[#8b4513] text-white' },
      { w: 'orange', t: 'orange', c: 'bg-[#f97316] text-black' },
      { w: 'jaune', t: 'yellow', c: 'bg-[#fef08a] text-black' },
      { w: 'vert', t: 'green', c: 'bg-[#16a34a] text-white' },
      { w: 'noir', t: 'black', c: 'bg-[#111827] text-white' }
    ]
  },
  {
    name: 'Nombres',
    bg: 'linear-gradient(135deg,#f59e0b 0%, #fbbf24 100%)',
    wordColors: ['#1e3a8a', '#1e40af', '#3b82f6', '#fef08a', '#facc15'],
    words: [
      { w: 'quatre', t: 'four', c: 'bg-[#facc15] text-black' },
      { w: 'trois', t: 'three', c: 'bg-[#3b82f6] text-white' },
      { w: 'deux', t: 'two', c: 'bg-[#1e40af] text-white' },
      { w: 'cinq', t: 'five', c: 'bg-[#1e3a8a] text-white' },
      { w: 'un', t: 'one', c: 'bg-[#fef08a] text-black' }
    ]
  },
  {
    name: 'Trésors & Jade',
    bg: 'linear-gradient(135deg,#fb923c 0%, #f97316 100%)',
    wordColors: ['#fed7aa', '#fdba74', '#fb923c', '#f97316', '#ea580c'],
    words: [
      { w: 'histoire', t: 'story', c: 'bg-[#ea580c] text-white' },
      { w: 'tresor', t: 'treasure', c: 'bg-[#fb923c] text-black' },
      { w: 'perle', t: 'pearl', c: 'bg-[#fdba74] text-black' },
      { w: 'coeur', t: 'heart', c: 'bg-[#fed7aa] text-black' },
      { w: 'jade', t: 'jade', c: 'bg-[#f97316] text-black' }
    ]
  },
  {
    name: 'Fêtes et Traditions',
    bg: 'linear-gradient(135deg,#f97316 0%, #fb923c 100%)',
    wordColors: ['#ffedd5', '#fed7aa', '#fb923c', '#ea580c', '#c2410c'],
    words: [
      { w: 'bastille', t: 'Bastille', c: 'bg-[#c2410c] text-white' },
      { w: 'defile', t: 'parade', c: 'bg-[#fb923c] text-black' },
      { w: 'paques', t: 'Easter', c: 'bg-[#fed7aa] text-black' },
      { w: 'noel', t: 'Christmas', c: 'bg-[#ffedd5] text-black' },
      { w: 'fete', t: 'party', c: 'bg-[#ea580c] text-black' }
    ]
  },
  {
    name: 'École',
    bg: 'linear-gradient(135deg,#ef4444 0%, #f87171 100%)',
    wordColors: ['#fee2e2', '#fecaca', '#f87171', '#ef4444', '#dc2626'],
    words: [
      { w: 'apprendre', t: 'to learn', c: 'bg-[#dc2626] text-white' },
      { w: 'etudiant', t: 'student', c: 'bg-[#f87171] text-white' },
      { w: 'classe', t: 'class', c: 'bg-[#fee2e2] text-black' },
      { w: 'prof', t: 'teacher', c: 'bg-[#fecaca] text-black' },
      { w: 'note', t: 'grade', c: 'bg-[#ef4444] text-white' }
    ]
  },
  {
    name: 'Esprit',
    bg: 'linear-gradient(135deg,#b91c1c 0%, #ef4444 100%)',
    wordColors: ['#fef2f2', '#fee2e2', '#f87171', '#ef4444', '#b91c1c'],
    words: [
      { w: 'coutume', t: 'custom', c: 'bg-[#b91c1c] text-white' },
      { w: 'medecin', t: 'medicine', c: 'bg-[#ef4444] text-white' },
      { w: 'savoir', t: 'knowledge', c: 'bg-[#f87171] text-white' },
      { w: 'priere', t: 'prayer', c: 'bg-[#fee2e2] text-black' },
      { w: 'esprit', t: 'spirit', c: 'bg-[#fef2f2] text-black' }
    ]
  },
  {
    name: 'Vie Quotidienne',
    bg: 'linear-gradient(135deg,#ec4899 0%, #f472b6 100%)',
    wordColors: ['#fce7f3', '#f9a8d4', '#ec4899', '#db2777', '#be185d'],
    words: [
      { w: 'travail', t: 'work', c: 'bg-[#db2777] text-white' },
      { w: 'dormir', t: 'sleep', c: 'bg-[#ec4899] text-white' },
      { w: 'manger', t: 'eat', c: 'bg-[#f9a8d4] text-black' },
      { w: 'aller', t: 'go', c: 'bg-[#fce7f3] text-black' },
      { w: 'lire', t: 'read', c: 'bg-[#be185d] text-white' }
    ]
  },
  {
    name: 'Communauté & Lieu',
    bg: 'linear-gradient(135deg,#db2777 0%, #ec4899 100%)',
    wordColors: ['#f9a8d4', '#ec4899', '#db2777', '#be185d', '#9d174d'],
    words: [
      { w: 'mairie', t: 'town hall', c: 'bg-[#9d174d] text-white' },
      { w: 'banque', t: 'bank', c: 'bg-[#db2777] text-white' },
      { w: 'eglise', t: 'church', c: 'bg-[#ec4899] text-white' },
      { w: 'parc', t: 'park', c: 'bg-[#f9a8d4] text-black' },
      { w: 'rue', t: 'street', c: 'bg-[#be185d] text-white' }
    ]
  },
  {
    name: 'Sentiments',
    bg: 'linear-gradient(135deg,#a855f7 0%, #c084fc 100%)',
    wordColors: ['#e9d5ff', '#d8b4fe', '#c084fc', '#a855f7', '#9333ea'],
    words: [
      { w: 'heureux', t: 'happy', c: 'bg-[#9333ea] text-white' },
      { w: 'triste', t: 'sad', c: 'bg-[#a855f7] text-white' },
      { w: 'colere', t: 'anger', c: 'bg-[#c084fc] text-black' },
      { w: 'peur', t: 'fear', c: 'bg-[#d8b4fe] text-black' },
      { w: 'joie', t: 'joy', c: 'bg-[#e9d5ff] text-black' }
    ]
  },
  {
    name: 'Actions',
    bg: 'linear-gradient(135deg,#7e22ce 0%, #a78bfa 100%)',
    wordColors: ['#ddd6fe', '#c4b5fd', '#a78bfa', '#7e22ce', '#6b21a8'],
    words: [
      { w: 'marcher', t: 'walk', c: 'bg-[#7e22ce] text-white' },
      { w: 'chanter', t: 'sing', c: 'bg-[#a78bfa] text-black' },
      { w: 'danser', t: 'dance', c: 'bg-[#c4b5fd] text-black' },
      { w: 'courir', t: 'run', c: 'bg-[#ddd6fe] text-black' },
      { w: 'jouer', t: 'play', c: 'bg-[#6b21a8] text-white' }
    ]
  },
  {
    name: 'Transport',
    bg: 'linear-gradient(135deg,#ff0000 0%, #ff7f00 100%)',
    wordColors: ['#fed7aa', '#fdba74', '#fb923c', '#f97316', '#ea580c'],
    words: [
      { w: 'voiture', t: 'car', c: 'bg-[#fdba74] text-black' },
      { w: 'camion', t: 'truck', c: 'bg-[#f97316] text-black' },
      { w: 'avion', t: 'plane', c: 'bg-[#fb923c] text-black' },
      { w: 'train', t: 'train', c: 'bg-[#fed7aa] text-black' },
      { w: 'bus', t: 'bus', c: 'bg-[#ea580c] text-white' }
    ]
  },
  {
    name: 'Esprits & Légendes',
    bg: 'linear-gradient(135deg,#ff7f00 0%, #ffff00 100%)',
    wordColors: ['#fef9c3', '#fef08a', '#facc15', '#eab308', '#ca8a04'],
    words: [
      { w: 'sorcier', t: 'sorcerer', c: 'bg-[#ca8a04] text-white' },
      { w: 'dragon', t: 'dragon', c: 'bg-[#facc15] text-black' },
      { w: 'elfe', t: 'elf', c: 'bg-[#fef9c3] text-black' },
      { w: 'roi', t: 'king', c: 'bg-[#fef08a] text-black' },
      { w: 'fee', t: 'fairy', c: 'bg-[#eab308] text-black' }
    ]
  },
  {
    name: 'Nourriture',
    bg: 'linear-gradient(135deg,#ff0000 0%, #ff7f00 50%, #ffff00 100%)',
    wordColors: ['#fef9c3', '#fef08a', '#facc15', '#eab308', '#ca8a04'],
    words: [
      { w: 'baguette', t: 'baguette', c: 'bg-[#eab308] text-black' },
      { w: 'fromage', t: 'cheese', c: 'bg-[#facc15] text-black' },
      { w: 'salade', t: 'salad', c: 'bg-[#fef08a] text-black' },
      { w: 'viande', t: 'meat', c: 'bg-[#fef9c3] text-black' },
      { w: 'eau', t: 'water', c: 'bg-[#ca8a04] text-white' }
    ]
  },
  {
    name: 'Ciel',
    bg: 'linear-gradient(135deg,#ff0000 0%, #ff7f00 33%, #ffff00 66%, #00ff00 100%)',
    wordColors: ['#fef9c3', '#fef08a', '#facc15', '#eab308', '#ca8a04'],
    words: [
      { w: 'soleil', t: 'sun', c: 'bg-[#facc15] text-black' },
      { w: 'etoile', t: 'star', c: 'bg-[#fef08a] text-black' },
      { w: 'nuage', t: 'cloud', c: 'bg-[#fef9c3] text-black' },
      { w: 'pluie', t: 'rain', c: 'bg[#eab308] text-black' },
      { w: 'lune', t: 'moon', c: 'bg-[#ca8a04] text-white' }
    ]
  },
  {
    name: 'Météo',
    bg: 'linear-gradient(135deg,#94a3b8 0%, #64748b 100%)',
    wordColors: ['#e6eef8', '#cfe1fb', '#9cc4ff', '#7da9ff', '#4b6eff'],
    words: [
      { w: 'orage', t: 'storm', c: 'bg-[#4b6eff] text-white' },
      { w: 'vent', t: 'wind', c: 'bg-[#7da9ff] text-white' },
      { w: 'pluie', t: 'rain', c: 'bg-[#9cc4ff] text-black' },
      { w: 'neige', t: 'snow', c: 'bg-[#cfe1fb] text-black' },
      { w: 'soleil', t: 'sun', c: 'bg-[#e6eef8] text-black' }
    ]
  },
  {
    name: 'Animaux',
    bg: 'linear-gradient(135deg,#f59e0b 0%, #fbbf24 100%)',
    wordColors: ['#fef3c7', '#fde68a', '#fcd34d', '#fbbf24', '#f59e0b'],
    words: [
      { w: 'cheval', t: 'horse', c: 'bg-[#f59e0b] text-black' },
      { w: 'chien', t: 'dog', c: 'bg-[#fbbf24] text-black' },
      { w: 'chat', t: 'cat', c: 'bg-[#fcd34d] text-black' },
      { w: 'lion', t: 'lion', c: 'bg-[#fde68a] text-black' },
      { w: 'rat', t: 'rat', c: 'bg-[#fef3c7] text-black' }
    ]
  },
  {
    name: 'Sports',
    bg: 'linear-gradient(135deg,#ef4444 0%, #b91c1c 100%)',
    wordColors: ['#fee2e2', '#fecaca', '#f87171', '#ef4444', '#b91c1c'],
    words: [
      { w: 'football', t: 'football', c: 'bg-[#b91c1c] text-white' },
      { w: 'natation', t: 'swimming', c: 'bg-[#ef4444] text-white' },
      { w: 'tennis', t: 'tennis', c: 'bg-[#f87171] text-black' },
      { w: 'rugby', t: 'rugby', c: 'bg-[#fecaca] text-black' },
      { w: 'ski', t: 'ski', c: 'bg-[#fee2e2] text-black' }
    ]
  }
];


        let currentLevel = 0;

       const LEVEL_COMPLETION_MESSAGES = [
    "Bien joué! – Ka pai! – Good job!",
    "Très bien! – Tino pai! – Very good!",
    "Génial! – Ka rawe! – Awesome!",
    "Excellent! – Pai rawa! – Excellent!",
    "Bon travail! – Ka pai tō mahi! – Good work!",
    "Vraiment excellent! – He pai rawa atu! – Really excellent!",
    "Incroyable! – Ka mau te wehi! – Amazing!",
    "Ton travail est fantastique! – He whakamīharo tō mahi! – Your work is fantastic!",
    "Tu es un champion! – Ka toa! – You are a champion!",
    "Tu es un héros! – He toa koe! – You are a hero!",
    "Reste fort! – Kia kaha! – Stay strong!",
    "Sois persévérant! – Kia manawanui! – Be steadfast!",
    "Fantastique! – Ka whakamīharo! – Fantastic!",
    "Tu l’as fait! – Ka ū! – You did it!",
    "Félicitations! – Ngā mihi! – Congratulations!",
    "Grandes félicitations! – Ngā mihi nui! – Big congratulations!",
    "Absolument génial! – Ka rawe rawa! – Absolutely awesome!",
    "Ton travail est très fort! – He tino kaha tō mahi! – Your work is very strong!",
    "Vraiment incroyable! – He tino whakamīharo! – Truly amazing!",
    "Louanges suprêmes! – Ngā manaakitanga! – Highest praise!"
];


        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createTile(row, col, letter, colorClass) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            if (colorClass) tile.classList.add(...colorClass.split(' '));
            tile.dataset.row = row;
            tile.dataset.col = col;
            tile.dataset.letter = letter;
            tile.innerHTML = `<span>${letter.toUpperCase()}</span>`;
            return tile;
        }

        function createStar(index) {
            const star = document.createElement('div');
            star.classList.add('star');
            star.dataset.index = index;
            star.style.backgroundColor = starsUsedCount <= index ? '#ffffff' : '#9ca3af';
            star.style.transform = starsUsedCount <= index ? 'scale(2)' : 'scale(1)';
            if (starsUsedCount <= index) {
                star.addEventListener('click', () => handleStarClick(index));
            } else {
                star.classList.add('used');
            }
            starContainer.appendChild(star);
            return star;
        }

        function initStars() {
            starContainer.innerHTML = '';
            stars = [];
            for (let i = 0; i < TOTAL_STARS; i++) {
                const star = createStar(i);
                stars.push({ element: star, used: starsUsedCount > i });
            }
        }

        function initProgressBar() {
            progressBar.innerHTML = '';
            for (let i = 0; i < LEVELS.length; i++) {
                const square = document.createElement('div');
                square.classList.add('progress-square');
                square.textContent = i + 1;
                if (completedLevels.has(i)) {
                    square.classList.add(`bg-level-${i + 1}`);
                    square.style.color = '#ffffff';
                }
                progressBar.appendChild(square);
            }
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        function displayWordList() {
            wordListEl.innerHTML = '';
            wordsToFind.forEach(word => {
                const count = foundWordCounts[word] || 0;
                const info = wordInfo[word];
                const wordItem = document.createElement('div');
                wordItem.classList.add('word-item');
                if (info && info.color) wordItem.classList.add(...info.color.split(' '));

                const left = document.createElement('div');
                left.style.display = 'flex';
                left.style.flexDirection = 'column';
                left.style.alignItems = 'flex-start';

                const wordText = document.createElement('span');
                wordText.classList.add('word-item-text');
                wordText.textContent = word.toUpperCase();

                const translation = document.createElement('small');
                translation.style.fontWeight = '600';
                translation.style.marginTop = '4px';
                translation.style.opacity = count > 0 ? '1' : '0.0';
                translation.textContent = count > 0 ? `(${info ? info.translation : ''})` : '';

                left.appendChild(wordText);
                left.appendChild(translation);

                const wordCount = document.createElement('span');
                wordCount.classList.add('word-item-count');
                wordCount.innerHTML = count > 0 ? '<span class="tick">✓</span>' : '';

                wordItem.appendChild(left);
                wordItem.appendChild(wordCount);

                wordListEl.appendChild(wordItem);
            });
        }

        function displayLearningLog() {
            learningLogList.innerHTML = '';
            foundWordsTrail.forEach(item => {
                const wordItem = document.createElement('div');
                wordItem.classList.add('word-item');
                wordItem.innerHTML = `
                    <span>${item.time}</span> - 
                    <span>${item.level}</span> - 
                    <span>${item.type}</span> - 
                    <span>${item.word}</span> - 
                    <span>${item.translation}</span> - 
                    <span>${item.timeTaken}s</span> - 
                    <span>${item.pointsGained}</span> - 
                    <span>${item.pointsTotal}</span>`;
                learningLogList.appendChild(wordItem);
            });
        }

        function placeWord(wordObj, board) {
            const word = wordObj.w;
            const directions = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            let placed = false;
            let attempts = 0;
            const maxAttempts = 100;
            const startTime = performance.now();

            while (!placed && attempts < maxAttempts && performance.now() - startTime < 1000) {
                const startR = Math.floor(Math.random() * GRID_SIZE);
                const startC = Math.floor(Math.random() * GRID_SIZE);
                const path = [{r:startR,c:startC}];
                const visited = new Set([`${startR},${startC}`]);

                const findPath = (r,c,wordIndex,depth=0) => {
                    if (wordIndex === word.length) return true;
                    if (depth > word.length * 2) return false;
                    shuffle(directions);
                    for (const [dr,dc] of directions) {
                        const newR = r + dr; 
                        const newC = c + dc;
                        const key = `${newR},${newC}`;
                        if (newR>=0 && newR<GRID_SIZE && newC>=0 && newC<GRID_SIZE && !visited.has(key)) {
                            const cell = board[newR][newC];
                            if (cell === null || cell === undefined || cell.word === null) {
                                visited.add(key); 
                                path.push({r:newR,c:newC});
                                if (findPath(newR,newC,wordIndex+1,depth+1)) return true;
                                path.pop(); 
                                visited.delete(key);
                            }
                        }
                    }
                    return false;
                };

                const startCell = board[startR][startC];
                if (startCell === null || startCell === undefined || startCell.word === null) {
                    if (findPath(startR,startC,1)) {
                        if (path.length === word.length) {
                            for (let i=0;i<word.length;i++){
                                const {r,c} = path[i];
                                board[r][c] = { letter: word[i], word: word, color: wordObj.c };
                            }
                            placed = true;
                            wordPlacementCounts[word] = (wordPlacementCounts[word] || 0) + 1;
                        }
                    }
                }
                attempts++;
            }
            return placed;
        }

        function validateBoard(board) {
            const wordsOnGrid = new Set();
            const directions = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            function checkPath(r, c, word, wordIndex, path, visited, depth=0) {
                if (wordIndex === word.length) return true;
                if (depth > word.length * 2) return false;
                for (const [dr, dc] of directions) {
                    const newR = r + dr; const newC = c + dc;
                    const key = `${newR},${newC}`;
                    if (newR >= 0 && newR < GRID_SIZE && newC >= 0 && newC < GRID_SIZE && !visited.has(key)) {
                        if (board[newR][newC] && board[newR][newC].letter === word[wordIndex]) {
                            visited.add(key); path.push({r:newR,c:newC});
                            if (checkPath(newR, newC, word, wordIndex + 1, path, visited, depth+1)) return true;
                            path.pop(); visited.delete(key);
                        }
                    }
                }
                return false;
            }

            for (const word of wordsToFind) {
                let found = false;
                for (let r = 0; r < GRID_SIZE && !found; r++) {
                    for (let c = 0; c < GRID_SIZE && !found; c++) {
                        if (board[r][c] && board[r][c].letter === word[0]) {
                            const path = [{r,c}];
                            const visited = new Set([`${r},${c}`]);
                            if (checkPath(r, c, word, 1, path, visited) && path.length === word.length) {
                                wordsOnGrid.add(word);
                                found = true;
                            }
                        }
                    }
                }
            }
            return wordsOnGrid.size === wordsToFind.length;
        }

        function getAllWords() {
            return LEVELS.flatMap(level => level.words.map(w => w.w));
        }

        function getBonusWords() {
            return BONUS_WORDS.map(w => ({ w: w.w, c: null }));
        }

        function initTranslations() {
            normalizedTranslations = {};
            LEVELS.forEach(level => {
                level.words.forEach(wObj => {
                    const normalized = wObj.w.replace(/[\s-]/g, '').toLowerCase();
                    normalizedTranslations[normalized] = wObj.t;
                });
            });
            BONUS_WORDS.forEach(bObj => {
                const normalized = bObj.w.replace(/[\s-]/g, '').toLowerCase();
                normalizedTranslations[normalized] = bObj.t;
            });
        }

        function getTranslation(word) {
            return normalizedTranslations[word.toLowerCase()] || 'bonus word';
        }

        function refreshBoard() {
            const MAX_OVERALL_ATTEMPTS = 50;
            const startTime = performance.now();
            let overallAttempt = 0;
            let success = false;
            let words = wordsToFind.map(w => wordInfo[w].obj);
            words.sort((a, b) => b.w.length - a.length);

            while (!success && overallAttempt < MAX_OVERALL_ATTEMPTS && performance.now() - startTime < 2000) {
                const localBoard = Array.from({length:GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
                let allPlaced = true;
                for (const wobj of words) {
                    const placed = placeWord(wobj, localBoard);
                    if (!placed) { allPlaced = false; break; }
                }
                if (allPlaced && validateBoard(localBoard)) {
                    let otherWords = shuffle([...getAllWords(), ...getBonusWords().map(w => w.w)]).slice(0, 5);
                    otherWords.sort((a, b) => b.length - a.length);
                    const purpleShades = [
                        'bg-[#c084fc] text-black',
                        'bg-[#a855f7] text-white',
                        'bg-[#9333ea] text-white',
                        'bg-[#7e22ce] text-white',
                        'bg-[#6b21a8] text-white'
                    ];
                    for (let i = 0; i < otherWords.length; i++) {
                        let wordObj = { w: otherWords[i], c: purpleShades[i % purpleShades.length] };
                        placeWord(wordObj, localBoard);
                    }
                    let remainingWords = shuffle(getAllWords().filter(w => w.length === 5 || w.length === 4));
                    let remainingWordIndex = 0;
                    const vowels = ['a', 'e', 'i', 'o', 'u', 'ā', 'ē', 'ī', 'ō', 'ū'];
                    let vowelIndex = 0;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (localBoard[r][c] === null) {
                                if (remainingWordIndex < remainingWords.length) {
                                    let wordObj = { w: remainingWords[remainingWordIndex], c: 'bg-[#d8b4fe] text-black' };
                                    if (placeWord(wordObj, localBoard)) {
                                        remainingWordIndex++;
                                    } else {
                                        localBoard[r][c] = { letter: vowels[vowelIndex], word: null, color: 'bg-[#d8b4fe] text-black' };
                                        vowelIndex = (vowelIndex + 1) % vowels.length;
                                    }
                                } else {
                                    localBoard[r][c] = { letter: vowels[vowelIndex], word: null, color: 'bg-[#d8b4fe] text-black' };
                                    vowelIndex = (vowelIndex + 1) % vowels.length;
                                }
                            }
                        }
                    }
                    gameBoard = localBoard;
                    success = true;
                }
                overallAttempt++;
            }

            if (!success) {
                gameBoard = Array.from({length:GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
                for (const w of words) placeWord(w, gameBoard);
                let otherWords = shuffle([...getAllWords(), ...getBonusWords().map(w => w.w)]).slice(0, 5);
                otherWords.sort((a, b) => b.length - a.length);
                const purpleShades = [
                    'bg-[#c084fc] text-black',
                    'bg-[#a855f7] text-white',
                    'bg-[#9333ea] text-white',
                    'bg-[#7e22ce] text-white',
                    'bg-[#6b21a8] text-white'
                ];
                for (let i = 0; i < otherWords.length; i++) {
                    let wordObj = { w: otherWords[i], c: purpleShades[i % purpleShades.length] };
                    placeWord(wordObj, gameBoard);
                }
                let remainingWords = shuffle(getAllWords().filter(w => w.length === 5 || w.length === 4));
                let remainingWordIndex = 0;
                const vowels = ['a', 'e', 'i', 'o', 'u', 'ā', 'ē', 'ī', 'ō', 'ū'];
                let vowelIndex = 0;
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (gameBoard[r][c] === null) {
                            if (remainingWordIndex < remainingWords.length) {
                                let wordObj = { w: remainingWords[remainingWordIndex], c: 'bg-[#d8b4fe] text-black' };
                                if (placeWord(wordObj, gameBoard)) {
                                    remainingWordIndex++;
                                } else {
                                    gameBoard[r][c] = { letter: vowels[vowelIndex], word: null, color: 'bg-[#d8b4fe] text-black' };
                                    vowelIndex = (vowelIndex + 1) % vowels.length;
                                }
                            } else {
                                gameBoard[r][c] = { letter: vowels[vowelIndex], word: null, color: 'bg-[#d8b4fe] text-black' };
                                vowelIndex = (vowelIndex + 1) % vowels.length;
                            }
                        }
                    }
                }
                if (!validateBoard(gameBoard)) {
                    showMessage('Board may be incomplete. Use a star to refresh.');
                }
            }

            renderBoard();
            displayWordList();
        }

        function initBoard() {
            foundWordCounts = {};
            wordPlacementCounts = {};
            const level = LEVELS[currentLevel];
            wordsToFind = level.words.map(o => o.w);
            wordInfo = {};
            level.words.forEach(o => {
                wordInfo[o.w] = { translation: o.t, color: o.c, obj: o };
                foundWordCounts[o.w] = 0;
                wordPlacementCounts[o.w] = 0;
            });

            document.body.style.background = level.bg;
            levelIndicator.textContent = `Level ${currentLevel + 1} / ${LEVELS.length} — ${level.name}`;
            initStars();
            initProgressBar();
            updateScoreDisplay();
            refreshBoard();
        }

        function renderBoard() {
            for (let r = 0; r < GRID_SIZE; r++) {
                if (!gameBoard[r]) gameBoard[r] = Array(GRID_SIZE).fill(null);
                for (let c = 0; c < GRID_SIZE; c++) if (!gameBoard[r][c]) {
                    const vowels = ['a', 'e', 'i', 'o', 'u', 'ā', 'ē', 'ī', 'ō', 'ū'];
                    gameBoard[r][c] = { letter: vowels[Math.floor(Math.random() * vowels.length)], word: null, color: 'bg-[#d8b4fe] text-black' };
                }
            }
            gridContainer.innerHTML = '';
            gameBoard.forEach((row, r) => {
                row.forEach((cell, c) => {
                    const tile = createTile(r, c, cell.letter, cell.color);
                    tile.addEventListener('click', () => handleTileClick(r, c));
                    gridContainer.appendChild(tile);
                    cell.element = tile;
                });
            });
        }

        function getSelectedWord() {
            return selectedTiles.map(t => gameBoard[t.row][t.col].letter).join('');
        }

        function isValidAdjacency(newTile) {
            if (selectedTiles.length === 0) return true;
            const last = selectedTiles[selectedTiles.length - 1];
            const dx = Math.abs(newTile.row - last.row);
            const dy = Math.abs(newTile.col - last.col);
            return (dx <= 1 && dy <= 1 && (dx > 0 || dy > 0));
        }

        function showMessage(text, duration = 1400) {
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            setTimeout(() => { messageBox.style.opacity = '0'; }, duration);
        }

        function clearHighlights() {
            document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
            selectedTiles = [];
            wordBuilderEl.innerHTML = '';
        }

        function handleStarClick(index) {
            if (stars[index].used || isDragging) return;
            stars[index].used = true;
            stars[index].element.classList.add('used');
            stars[index].element.style.backgroundColor = '#9ca3af';
            stars[index].element.style.transform = 'scale(1)';
            stars[index].element.removeEventListener('click', () => handleStarClick(index));
            starsUsedCount++;
            refreshBoard();
            showMessage('Board refreshed!');
        }

        function handleTileClick(row, col) {
            const newTile = { row, col };
            const isAlready = selectedTiles.some(t => t.row === row && t.col === col);
            if (isAlready) {
                // Deselect tiles up to the clicked tile
                const index = selectedTiles.findIndex(t => t.row === row && t.col === col);
                selectedTiles = selectedTiles.slice(0, index + 1);
                document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
                selectedTiles.forEach(t => {
                    const tile = document.querySelector(`.tile[data-row="${t.row}"][data-col="${t.col}"]`);
                    tile.classList.add('selected');
                });
                wordBuilderEl.innerHTML = '';
                selectedTiles.forEach(t => {
                    const built = document.createElement('div');
                    built.classList.add('built-letter');
                    built.textContent = gameBoard[t.row][t.col].letter.toUpperCase();
                    wordBuilderEl.appendChild(built);
                });
            } else if (isValidAdjacency(newTile)) {
                if (selectedTiles.length === 0) {
                    selectionStartTime = Date.now(); // Start timing
                }
                selectedTiles.push(newTile);
                const tile = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
                tile.classList.add('selected');
                const built = document.createElement('div');
                built.classList.add('built-letter');
                built.textContent = gameBoard[row][col].letter.toUpperCase();
                wordBuilderEl.appendChild(built);
            }
        }

        function handleStart(e) {
            isDragging = true;
            selectionStartTime = Date.now(); // Start timing
            handleMove(e);
        }

        function handleMove(e) {
            if (!isDragging) return;
            const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
            const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
            const target = document.elementFromPoint(clientX, clientY);
            const tile = target && target.closest('.tile');
            if (tile && tile !== lastTile) {
                const row = parseInt(tile.dataset.row);
                const col = parseInt(tile.dataset.col);
                const newTile = {row, col};
                const isAlready = selectedTiles.some(t => t.row === row && t.col === col);
                if (!isAlready && isValidAdjacency(newTile)) {
                    selectedTiles.push(newTile);
                    tile.classList.add('selected');
                    lastTile = tile;
                    const built = document.createElement('div');
                    built.classList.add('built-letter');
                    built.textContent = gameBoard[row][col].letter.toUpperCase();
                    wordBuilderEl.appendChild(built);
                }
            }
        }

        function handleEnd() {
            if (!isDragging) return;
            isDragging = false;
            lastTile = null;
            const timeTaken = Math.round((Date.now() - selectionStartTime) / 1000); // Calculate time taken in seconds
            const word = getSelectedWord().toLowerCase();
            const foundWord = wordsToFind.find(w => w === word);
            const allWords = [...getAllWords(), ...getBonusWords().map(w => w.w)];
            const isBonusWord = !foundWord && allWords.includes(word);
            const levelName = `Level ${currentLevel + 1} - ${LEVELS[currentLevel].name}`;

            if (foundWord && word.length >= 2) {
                foundWordCounts[foundWord] = (foundWordCounts[foundWord] || 0) + 1;
                const pointsGained = word.length;
                score += pointsGained;
                showMessage('Mīharo - you got it!');
                dropLettersAndRefill(selectedTiles);
                const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const translation = wordInfo[foundWord].translation;
                foundWordsTrail.push({
                    time,
                    level: levelName,
                    type: 'List Word',
                    word: word.toUpperCase(),
                    translation,
                    timeTaken,
                    pointsGained,
                    pointsTotal: score
                });
                displayWordList();
                displayLearningLog();
                updateScoreDisplay();
            } else if (isBonusWord && word.length >= 2) {
                const pointsGained = word.length * 5;
                score += pointsGained;
                const type = getAllWords().includes(word) ? 'Bonus Word (list)' : 'Bonus Word (hidden)';
                showMessage('Ka rawe! Bonus word found!');
                dropLettersAndRefill(selectedTiles);
                const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const translation = getTranslation(word);
                foundWordsTrail.push({
                    time,
                    level: levelName,
                    type,
                    word: word.toUpperCase(),
                    translation,
                    timeTaken,
                    pointsGained,
                    pointsTotal: score
                });
                displayLearningLog();
                updateScoreDisplay();
            } else if (word.length > 1) {
                showMessage('That is not a valid word.');
            }
            clearHighlights();
            checkWinCondition();
        }

        function dropLettersAndRefill(tilesToRemove) {
            const newGameBoard = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
            const removeSet = new Set(tilesToRemove.map(t => `${t.row},${t.col}`));
            for (let c = 0; c < GRID_SIZE; c++) {
                const columnStack = [];
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    const coord = `${r},${c}`;
                    if (!removeSet.has(coord) && gameBoard[r][c]) columnStack.push(gameBoard[r][c]);
                }
                let fillRow = GRID_SIZE - 1;
                for (let i = 0; i < columnStack.length; i++) {
                    newGameBoard[fillRow][c] = columnStack[i];
                    fillRow--;
                }
            }
            gameBoard = newGameBoard;

            const wordsToFindStillRemaining = wordsToFind.filter(w => foundWordCounts[w] < FIND_COUNT_PER_WORD);
            const wordsOnGrid = new Set();
            for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) if (gameBoard[r][c] && gameBoard[r][c].word) wordsOnGrid.add(gameBoard[r][c].word);
            let attempts = 0;
            const maxAttempts = 100;
            const startTime = performance.now();
            while (wordsOnGrid.size < wordsToFindStillRemaining.length && attempts < maxAttempts && performance.now() - startTime < 1000) {
                let wordsNotOnGrid = wordsToFindStillRemaining.filter(w => !wordsOnGrid.has(w));
                wordsNotOnGrid.sort((a, b) => b.length - a.length);
                for (const w of wordsNotOnGrid) {
                    if (placeWord(wordInfo[w].obj, gameBoard)) {
                        wordsOnGrid.add(w);
                    }
                }
                if (wordsOnGrid.size < wordsToFindStillRemaining.length) {
                    const nonWordTiles = [];
                    for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) if (!gameBoard[r][c] || !gameBoard[r][c].word) nonWordTiles.push({r, c});
                    shuffle(nonWordTiles);
                    const tilesToReplace = nonWordTiles.slice(0, Math.min(20, nonWordTiles.length));
                    tilesToReplace.forEach(({r, c}) => gameBoard[r][c] = null);
                    for (const w of wordsNotOnGrid) {
                        if (placeWord(wordInfo[w].obj, gameBoard)) {
                            wordsOnGrid.add(w);
                        }
                    }
                }
                attempts++;
            }
            if (wordsOnGrid.size < wordsToFindStillRemaining.length) {
                showMessage('Some main words could not be placed. Use a star to refresh if needed.');
            }

            let otherWords = shuffle([...getAllWords(), ...getBonusWords().map(w => w.w)]).slice(0, 5);
            otherWords.sort((a, b) => b.length - a.length);
            const purpleShades = [
                'bg-[#c084fc] text-black',
                'bg-[#a855f7] text-white',
                'bg-[#9333ea] text-white',
                'bg-[#7e22ce] text-white',
                'bg-[#6b21a8] text-white'
            ];
            for (let i = 0; i < otherWords.length; i++) {
                let wordObj = { w: otherWords[i], c: purpleShades[i % purpleShades.length] };
                placeWord(wordObj, gameBoard);
            }

            let remainingWords = shuffle(getAllWords().filter(w => w.length === 5 || w.length === 4));
            let remainingWordIndex = 0;
            const vowels = ['a', 'e', 'i', 'o', 'u', 'ā', 'ē', 'ī', 'ō', 'ū'];
            let vowelIndex = 0;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (gameBoard[r][c] === null) {
                        if (remainingWordIndex < remainingWords.length) {
                            let wordObj = { w: remainingWords[remainingWordIndex], c: 'bg-[#d8b4fe] text-black' };
                            if (placeWord(wordObj, gameBoard)) {
                                remainingWordIndex++;
                            } else {
                                gameBoard[r][c] = { letter: vowels[vowelIndex], word: null, color: 'bg-[#d8b4fe] text-black' };
                                vowelIndex = (vowelIndex + 1) % vowels.length;
                            }
                        } else {
                            gameBoard[r][c] = { letter: vowels[vowelIndex], word: null, color: 'bg-[#d8b4fe] text-black' };
                            vowelIndex = (vowelIndex + 1) % vowels.length;
                        }
                    }
                }
            }

            renderBoard();
        }

        function checkWinCondition() {
            const allFound = wordsToFind.every(word => foundWordCounts[word] >= FIND_COUNT_PER_WORD);
            if (allFound) {
                completedLevels.add(currentLevel);
                gameContainer.querySelectorAll('*').forEach(n => n.style.display = '');
                winScreen.classList.remove('hidden');
                const winText = currentLevel < LEVELS.length - 1 ? LEVEL_COMPLETION_MESSAGES[currentLevel] : 'Ka Mutu Katoa!';
                const buttonsHTML = `
                    <button class="win-button" id="replay-level-btn">Replay</button>
                    ${currentLevel < LEVELS.length - 1 ? '<button class="win-button" id="next-level-btn">Next</button>' : ''}
                `;
                winScreen.innerHTML = `
                    <div class="win-overlay">
                        <div class="win-star"></div>
                        <div class="win-text">${winText}</div>
                        <div class="win-buttons">${buttonsHTML}</div>
                    </div>`;
                // Add level completion to learning log
                foundWordsTrail.push({
                    time: '',
                    level: '',
                    type: '',
                    word: `Level ${currentLevel + 1}: ${LEVEL_COMPLETION_MESSAGES[currentLevel]}`,
                    translation: '',
                    timeTaken: '',
                    pointsGained: '',
                    pointsTotal: score
                });
                displayLearningLog();
                document.getElementById('replay-level-btn').addEventListener('click', () => resetGame());
                if (currentLevel < LEVELS.length - 1) {
                    document.getElementById('next-level-btn').addEventListener('click', () => nextLevel());
                }
                initProgressBar();
            }
        }

        function resetGame() {
            winScreen.classList.add('hidden');
            winScreen.innerHTML = '';
            initBoard();
        }

        function prevLevel() {
            if (currentLevel > 0) {
                currentLevel--;
                resetGame();
            }
        }

        function nextLevel() {
            if (currentLevel < LEVELS.length - 1) {
                currentLevel++;
                resetGame();
            }
        }

function attachEventListeners() {
    gridContainer.addEventListener('mousedown', handleStart);
    gridContainer.addEventListener('mousemove', handleMove);
    gridContainer.addEventListener('mouseup', handleEnd);
    gridContainer.addEventListener('mouseleave', handleEnd);
    gridContainer.addEventListener('touchstart', (e) => handleStart(e.touches[0]));
    gridContainer.addEventListener('touchmove', (e) => handleMove(e.touches[0]));
    gridContainer.addEventListener('touchend', handleEnd);

    prevLevelBtn.addEventListener('click', () => { prevLevel(); });
    nextLevelBtn.addEventListener('click', () => { nextLevel(); });
    instructionsBtn.addEventListener('click', () => {
        instructionsModal.style.display = 'flex';
    });
    modalClose.addEventListener('click', () => {
        instructionsModal.style.display = 'none';
    });
    copyTrailBtn.addEventListener('click', copyToClipboard);




function copyToClipboard() {
    try {
        const now = new Date().toLocaleString('en-NZ', {
            weekday: 'long',
            month: 'long',
            day: '2-digit',
            year: 'numeric'
        });

        const maoriDays = {
            'Monday': 'Mane','Tuesday': 'Tūrei','Wednesday': 'Wenerei','Thursday': 'Tāite',
            'Friday': 'Paraire','Saturday': 'Rāhoroi','Sunday': 'Rātapu'
        };
        const maoriMonths = {
            'January': 'Kohitātea','February': 'Hui-tanguru','March': 'Poutū-te-rangi','April': 'Paenga-whāwhā',
            'May': 'Haratua','June': 'Pipiri','July': 'Hōngongoi','August': 'Hereturikōkā',
            'September': 'Mahuru','October': 'Whiringa-ā-nuku','November': 'Whiringa-ā-rangi','December': 'Hakihea'
        };
const frenchDays = {
    'Monday': 'Lundi',
    'Tuesday': 'Mardi',
    'Wednesday': 'Mercredi',
    'Thursday': 'Jeudi',
    'Friday': 'Vendredi',
    'Saturday': 'Samedi',
    'Sunday': 'Dimanche'
};

const frenchMonths = {
    'January': 'Janvier',
    'February': 'Février',
    'March': 'Mars',
    'April': 'Avril',
    'May': 'Mai',
    'June': 'Juin',
    'July': 'Juillet',
    'August': 'Août',
    'September': 'Septembre',
    'October': 'Octobre',
    'November': 'Novembre',
    'December': 'Décembre'
};



        const parts = now.split(/[, ]+/);
        const weekday = parts[0];
        const day = parts[1];
        const month = parts[2];
        const year = parts[3];
        const maoriDate = `${maoriDays[weekday]}, ${maoriMonths[month]} ${day}, ${year}`;
       const frenchDate = `${frenchDays[weekday]}, ${frenchMonths[month]} ${day}, ${year}`;
       const englishDate = `${weekday}, ${month} ${day}, ${year}`;


        const headers = [
            'Time',
            'Level',
            'Type',
            'French Mot',
            'Translation',
            'Time Taken',
            'Points Gained',
            'Points Total'
        ];

        const raw = (foundWordsTrail || []);

        // use flatMap so we can add spacer rows before/after specials
        const rows = raw.flatMap(item => {
            if (item.type === '') {
                return [
                    { spacer: true },
                    { 
                        special: true,
                        message: String(item.word || ''), 
                        pointsTotal: item.pointsTotal != null ? String(item.pointsTotal) : '' 
                    },
                    { spacer: true }
                ];
            } else {
                return [{
                    special: false,
                    fields: [
                        String(item.time || ''),
                        String(item.level || ''),
                        String(item.type || ''),
                        String(item.word || ''),
                        String(item.translation || ''),
                        item.timeTaken != null ? String(item.timeTaken) + 's' : '',
                        item.pointsGained != null ? String(item.pointsGained) : '',
                        item.pointsTotal != null ? String(item.pointsTotal) : ''
                    ]
                }];
            }
        });

        // compute column widths
        const colCount = headers.length;
        const colWidths = headers.map(h => h.length);
        rows.forEach(r => {
            if (r.special === false) {
                r.fields.forEach((f, i) => {
                    const len = String(f).length;
                    if (len > colWidths[i]) colWidths[i] = len;
                });
            } else if (r.special) {
                const ptLen = String(r.pointsTotal || '').length;
                if (ptLen > colWidths[colCount - 1]) colWidths[colCount - 1] = ptLen;
            }
        });

        //const GAP = 3; FROM HERE
        //for (let i = 0; i < colWidths.length - 1; i++) colWidths[i] += GAP;
        // Add GAP to all columns, including the second-to-last, to ensure spacing
        const GAP = 3;
        for (let i = 0; i < colWidths.length; i++) colWidths[i] += GAP;
        const align = ['left', 'left', 'left', 'left', 'left', 'right', 'right', 'right'];
        //const align = ['left','left','left','left','left','right','right','right']; TO HERE
        const padCell = (s, w, a) => {
            const str = String(s || '');
            return a === 'right' ? str.padStart(w, ' ') : str.padEnd(w, ' ');
        };

       // const headerRow = headers.map((h, i) => padCell(h, colWidths[i], 'left')).join('');
        const headerRow = headers.map((h, i) => padCell(h, colWidths[i], align[i])).join('');
        const underlineRow = colWidths.map(w => '-'.repeat(w)).join('');

        const combinedIndexStart = 3;
        const combinedIndexEnd = 6;

        const bodyRows = rows.map(r => {
            if (r.spacer) {
                return ''; // blank line
} else if (r.special) {
 //               const firstPart = padCell('', colWidths[0], 'left')
    //                            + padCell('', colWidths[1], 'left')
           //                     + padCell('', colWidths[2], 'left'); //Longer messages need more space
       //         const mergedWidth = colWidths.slice(combinedIndexStart, combinedIndexEnd + 1).reduce((a, b) => a + b, 0);
          //      const mergedPart = padCell(r.message, mergedWidth, 'left')
           //             + padCell('', colWidths[2], 'left') ;// keep spacing, don’t display text
              //  const lastPart = padCell(r.pointsTotal || '', colWidths[colCount - 1], 'right');
               // return firstPart + mergedPart + lastPart;
// CHATGPT replaced this code as the width of the congratualtions got too long, as I kept the Māori and added the French.
    // Width for everything except the last column (reserved for totals)
    const messageWidth = colWidths
        .slice(0, colCount - 1) // all columns except the last
        .reduce((sum, current) => sum + current, 0);
    // Put the special message across the left side
    const messagePart = padCell(r.message, messageWidth, 'left');
    // Totals column stays flush right
    const totalPart = padCell(r.pointsTotal || '', colWidths[colCount - 1], 'right');
    return messagePart + totalPart;
} else {
    return r.fields.map((f, i) => padCell(f, colWidths[i], align[i])).join('');
}
}).join('\n');

        const text = `<pre>Mots Mêlés Learning Log for ${frenchDate}    ${maoriDate}    ${englishDate}\n\n${headerRow}\n${underlineRow}\n${bodyRows}</pre>`;

        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = text;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        document.execCommand('copy');
        document.body.removeChild(tempTextArea);

        alert('Copied Learning Log to clipboard!');
    } catch (err) {
        alert('Failed to copy, aroha mai, select and control C: ' + err);
    }
}
}
initTranslations();
initBoard();
attachEventListeners();
}); 
</script>
</body>
</html>