<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Te Reo Crossword - 23 Sep 2025 - Draft</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&display=swap');

        :root {
            --grid-size: 3;
            --cell-size: min(12vw, 50px);
        }
        #crossword-container {
            font-family: 'Quicksand', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }
        .grid-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .crossword-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-template-rows: repeat(var(--grid-size), 1fr);
            border: 3px solid black;
            width: 90vw;
            max-width: 300px;
            aspect-ratio: 1 / 1;
        }
        .cell {
            border: 1px solid black;
            text-align: center;
            position: relative;
        }
        .cell input {
            width: 100%;
            height: 100%;
            text-align: center;
            border: none;
            font-size: clamp(16px, calc(var(--cell-size) / 2), 30px);
            background-color: white;
            box-sizing: border-box;
            text-transform: uppercase;
            color: black;
            caret-color: #007bff;
            font-family: 'Quicksand', sans-serif;
        }
        .cell.highlight input {
            background-color: #d0e8ff;
        }
        .cell input:focus {
            outline: 3px solid #007bff;
            outline-offset: -3px;
            background-color: #d0e8ff;
        }
        .cell.black {
            background-color: black;
        }
        .cell.black input {
            background-color: black;
            pointer-events: none;
        }
        .clue-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: clamp(8px, calc(var(--cell-size) / 5), 12px);
            font-weight: bold;
            pointer-events: none;
        }
        .clues-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 90vw;
            max-width: 400px;
        }
        .clues-list h2 {
            margin: 0 0 10px 0;
            font-size: 1.5em;
            color: #333;
        }
        .clues-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .clues-list li {
            margin-bottom: 8px;
            font-size: 1em;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
        }
        .clues-list li.active {
            background-color: #d0e8ff;
        }
        .button-container {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        .button-container button {
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            font-family: 'Quicksand', sans-serif;
            transition: background-color 0.3s;
        }
        .button-container button:hover {
            background-color: #0056b3;
        }
        .back-link {
            margin-top: 20px;
            font-size: 1.2em;
        }
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            font-family: 'Quicksand', sans-serif;
            margin: 15% auto;
            padding: 25px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            border-radius: 20px;
            border: 10px solid;
            border-image-slice: 1;
            border-image-source: linear-gradient(to left, #f44336, #e91e63, #9c27b0, #2196f3, #4caf50, #ffeb3b, #ff9800);
        }
        .modal-content h2 {
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(90deg, #f44336, #e91e63, #9c27b0, #673ab7, #3f51b5, #2196f3, #03a9f4, #00bcd4, #009688, #4caf50, #8bc34a, #cddc39, #ffeb3b, #ffc107, #ff9800, #ff5722);
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow-text 3s linear infinite;
        }
        @keyframes rainbow-text {
            to { background-position: 200% center; }
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        @media (min-width: 769px) {
            .game-area {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 40px;
            }
            .clues-container {
                max-width: 400px;
            }
        }
    </style>
</head>
<body>
    <section class="stage">
        <canvas id="confetti-canvas"></canvas>
        <div id="crossword-container">
            <h1>Te Reo Crossword - 23 Sep 2025 - Draft</h1>
            <div class="game-area">
                <div class="grid-container">
                    <div class="crossword-grid" id="crossword-grid"></div>
                    <div class="button-container">
                        <button id="check-puzzle">Check Puzzle</button>
                        <button id="reveal-puzzle">Reveal Puzzle</button>
                    </div>
                </div>
                <div class="clues-container">
                    <div id="language-toggle" class="button-container">
                        <button id="toggle-language">Te Reo Māori</button>
                    </div>
                    <div id="clues-across" class="clues-list">
                        <h2>Across</h2>
                        <ul></ul>
                    </div>
                    <div id="clues-down" class="clues-list">
                        <h2>Down</h2>
                        <ul></ul>
                    </div>
                </div>
            </div>
            <a href="index_crossword.html" class="back-link">Back to Crossword Index</a>
        </div>

        <div id="congrats-modal" class="modal">
            <div class="modal-content">
                <span class="close-button">&times;</span>
                <h2>Congratulations!</h2>
                <p>You've solved the puzzle!</p>
            </div>
        </div>
    </section>

    <script>
        (() => {
            const puzzleData = {
                size: 3,
                layout: [
                    [0, 0, 0],
                    [0, 0, 0],
                    [0, 0, 0]
                ],
                words: [
                    { word: "IKA", number: 1, clue_en: "Fish (Te Reo Māori).", clue_mi: "He ika.", row: 0, col: 0, direction: "across" },
                    { word: "RAE", number: 2, clue_en: "Forehead, brow (Te Reo Māori).", clue_mi: "Te pae o te anga; te ihu o te mahunga.", row: 1, col: 0, direction: "across" },
                    { word: "AUA", number: 3, clue_en: "Interjection: I don’t know/ don’t ask (Te Reo Māori).", clue_mi: "He kupu whakahoki pātai: kāore au i te mōhio.", row: 2, col: 0, direction: "across" },
                    { word: "IRA", number: 1, clue_en: "Essence, lineage; life-principle (Te Reo Māori).", clue_mi: "Te ira tangata; te pūtake ora.", row: 0, col: 0, direction: "down" },
                    { word: "KAU", number: 4, clue_en: "To swim; swim (verb root) (Te Reo Māori).", clue_mi: "He kupu tūāhua mō te kauhoe, te kau.", row: 0, col: 1, direction: "down" },
                    { word: "AEA", number: 5, clue_en: "It would be better / it were better (Te Reo Māori).", clue_mi: "He kī e tohu ana kāore e pai; he mea kia pai ake.", row: 0, col: 2, direction: "down" }
                ]
            };

            const gridElement = document.getElementById('crossword-grid');
            const cluesAcrossList = document.querySelector('#clues-across ul');
            const cluesDownList = document.querySelector('#clues-down ul');
            const modal = document.getElementById('congrats-modal');
            const closeButton = document.querySelector('.close-button');
            const toggleButton = document.getElementById('toggle-language');
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            
            let cells = [];
            let activeClueElement = null;
            let currentLanguage = 'en';

            let confetti = [];
            let streamers = [];
            const confettiCount = 200;
            const streamerCount = 50;
            const gravity = 0.1;
            const terminalVelocity = 5;
            const drag = 0.075;
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];

            function clearHighlights() {
                if (activeClueElement) {
                    activeClueElement.classList.remove('active');
                }
                activeClueElement = null;
                document.querySelectorAll('.cell.highlight').forEach(c => c.classList.remove('highlight'));
            }

            function highlightWord(word, row, col, direction) {
                clearHighlights();
                for (let i = 0; i < word.length; i++) {
                    let r = row, c = col;
                    if (direction === 'across') c += i; else r += i;
                    if (cells[r] && cells[r][c]) {
                        cells[r][c].element.classList.add('highlight');
                    }
                }
            }
            
            function handleClueClick(e) {
                const li = e.target.closest('li');
                if (!li) return;

                const { word, row, col, direction } = li.dataset;
                highlightWord(word, parseInt(row), parseInt(col), direction);
                
                activeClueElement = li;
                li.classList.add('active');
                cells[row][col].input.focus();
            }

            function handleInput(e) {
                const input = e.target;
                if (input.value.length === 0 || !activeClueElement) return;

                const { word, row, col, direction } = activeClueElement.dataset;
                const r = parseInt(input.dataset.row);
                const c = parseInt(input.dataset.col);

                let nextR = r, nextC = c;
                if (direction === 'across') nextC++; else nextR++;

                const endR = direction === 'down' ? parseInt(row) + word.length - 1 : parseInt(row);
                const endC = direction === 'across' ? parseInt(col) + word.length - 1 : parseInt(col);

                if (nextR <= endR && nextC <= endC && cells[nextR] && cells[nextR][nextC]) {
                    cells[nextR][nextC].input.focus();
                }
            }

            function handleKeyDown(e) {
                const r = parseInt(e.target.dataset.row);
                const c = parseInt(e.target.dataset.col);

                if (e.key.startsWith('Arrow')) {
                    e.preventDefault();
                    let nextR = r, nextC = c;
                    if (e.key === 'ArrowUp') nextR--;
                    if (e.key === 'ArrowDown') nextR++;
                    if (e.key === 'ArrowLeft') nextC--;
                    if (e.key === 'ArrowRight') nextC++;

                    if (nextR >= 0 && nextR < puzzleData.size && nextC >= 0 && nextC < puzzleData.size && !cells[nextR][nextC].element.classList.contains('black')) {
                        cells[nextR][nextC].input.focus();
                    }
                } else if (e.key === 'Backspace' && e.target.value === '' && activeClueElement) {
                    const { direction } = activeClueElement.dataset;
                    let prevR = r, prevC = c;
                    if (direction === 'across') prevC--; else prevR--;
                    
                    if (prevR >= 0 && prevC >= 0 && cells[prevR][prevC] && !cells[prevR][prevC].element.classList.contains('black')) {
                        cells[prevR][prevC].input.focus();
                    }
                }
            }

            function handleFocus(e) {
                const r = parseInt(e.target.dataset.row);
                const c = parseInt(e.target.dataset.col);
                
                const focusedCellData = puzzleData.words.find(word => {
                    if (word.direction === 'across') {
                        return r === word.row && c >= word.col && c < word.col + word.word.length;
                    } else {
                        return c === word.col && r >= word.row && r < word.row + word.word.length;
                    }
                });

                if (focusedCellData) {
                    const clueElement = document.querySelector(`li[data-word="${focusedCellData.word}"][data-direction="${focusedCellData.direction}"]`);
                    if (clueElement) {
                        clearHighlights();
                        activeClueElement = clueElement;
                        clueElement.classList.add('active');
                        highlightWord(focusedCellData.word, focusedCellData.row, focusedCellData.col, focusedCellData.direction);
                    }
                }
            }

            function createGrid() {
                gridElement.innerHTML = '';
                cells = [];
                document.documentElement.style.setProperty('--grid-size', puzzleData.size);

                for (let r = 0; r < puzzleData.size; r++) {
                    cells[r] = [];
                    for (let c = 0; c < puzzleData.size; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        const input = document.createElement('input');
                        input.maxLength = 1;
                        input.dataset.row = r;
                        input.dataset.col = c;
                        
                        // Check if a word exists at this cell
                        const isWordCell = puzzleData.words.some(word => {
                            if (word.direction === 'across') {
                                return r === word.row && c >= word.col && c < word.col + word.word.length;
                            } else {
                                return c === word.col && r >= word.row && r < word.row + word.word.length;
                            }
                        });

                        if (!isWordCell) {
                            cell.classList.add('black');
                        } else {
                            input.addEventListener('input', handleInput);
                            input.addEventListener('keydown', handleKeyDown);
                            input.addEventListener('focus', handleFocus);
                        }

                        cell.appendChild(input);
                        gridElement.appendChild(cell);
                        cells[r][c] = { element: cell, input: input };
                    }
                }
            }

            function populateClues() {
                cluesAcrossList.innerHTML = '';
                cluesDownList.innerHTML = '';

                // Add clue numbers to the grid
                puzzleData.words.forEach(word => {
                    const clueNumDiv = document.createElement('div');
                    clueNumDiv.classList.add('clue-number');
                    clueNumDiv.textContent = word.number;
                    cells[word.row][word.col].element.appendChild(clueNumDiv);
                });

                // Sort clues by number
                const sortedWords = puzzleData.words.sort((a, b) => a.number - b.number);

                sortedWords.forEach(word => {
                    const li = document.createElement('li');
                    const clueText = currentLanguage === 'en' ? word.clue_en : word.clue_mi;
                    li.innerHTML = `<strong>${word.number}.</strong> ${clueText}`;
                    li.dataset.word = word.word;
                    li.dataset.row = word.row;
                    li.dataset.col = word.col;
                    li.dataset.direction = word.direction;
                    if (word.direction === 'across') {
                        cluesAcrossList.appendChild(li);
                    } else {
                        cluesDownList.appendChild(li);
                    }
                });
            }

            function toggleLanguage() {
                currentLanguage = currentLanguage === 'en' ? 'mi' : 'en';
                populateClues();
                toggleButton.textContent = currentLanguage === 'en' ? 'Te Reo Māori' : 'English';
            }

            function triggerConfetti() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                confetti = [];
                streamers = [];

                for (let i = 0; i < confettiCount; i++) {
                    confetti.push({
                        x: Math.random() * canvas.width,
                        y: -Math.random() * canvas.height,
                        size: Math.random() * 6 + 4,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        velocity: { x: Math.random() * 4 - 2, y: Math.random() * 2 + 1 }
                    });
                }
                for (let i = 0; i < streamerCount; i++) {
                    streamers.push({
                        x: Math.random() * canvas.width,
                        y: -Math.random() * canvas.height,
                        length: Math.random() * 100 + 50,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        velocity: { x: Math.random() * 2 - 1, y: Math.random() * 2 + 2 }
                    });
                }
                drawConfetti();
            }

            let animationFrameId;
            function drawConfetti() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                confetti.forEach(c => {
                    c.y += c.velocity.y;
                    c.x += c.velocity.x;
                    c.velocity.y = Math.min(terminalVelocity, c.velocity.y + gravity);
                    ctx.fillStyle = c.color;
                    ctx.fillRect(c.x, c.y, c.size, c.size);
                });

                streamers.forEach(s => {
                    s.y += s.velocity.y;
                    s.x += s.velocity.x;
                    s.velocity.y = Math.min(terminalVelocity, s.velocity.y + gravity);
                    ctx.strokeStyle = s.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x, s.y + s.length);
                    ctx.stroke();
                });

                if (confetti.some(c => c.y < canvas.height) || streamers.some(s => s.y < canvas.height)) {
                    animationFrameId = requestAnimationFrame(drawConfetti);
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }
            
            function checkPuzzle() {
                let isCorrect = true;
                puzzleData.words.forEach(word => {
                    for (let i = 0; i < word.word.length; i++) {
                        let r = word.row, c = word.col;
                        if (word.direction === 'across') c += i; else r += i;
                        
                        if (cells[r] && cells[r][c] && cells[r][c].input) {
                            const inputElement = cells[r][c].input;
                            if (inputElement.value.toUpperCase() !== word.word[i]) {
                                inputElement.style.backgroundColor = '#ffdddd';
                                isCorrect = false;
                            } else {
                                inputElement.style.backgroundColor = '#ddffdd';
                            }
                        }
                    }
                });
                if (isCorrect) {
                    modal.style.display = "block";
                    triggerConfetti();
                }
            }

            function revealPuzzle() {
                clearHighlights();
                puzzleData.words.forEach(word => {
                    for (let i = 0; i < word.word.length; i++) {
                        let r = word.row, c = word.col;
                        if (word.direction === 'across') c += i; else r += i;
                        if (cells[r] && cells[r][c] && cells[r][c].input) {
                            cells[r][c].input.value = word.word[i];
                            cells[r][c].input.style.backgroundColor = 'white';
                        }
                    }
                });
            }
            
            closeButton.onclick = function() {
                modal.style.display = "none";
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }

            document.getElementById('check-puzzle').addEventListener('click', checkPuzzle);
            document.getElementById('reveal-puzzle').addEventListener('click', revealPuzzle);
            document.getElementById('toggle-language').addEventListener('click', toggleLanguage);
            cluesAcrossList.addEventListener('click', handleClueClick);
            cluesDownList.addEventListener('click', handleClueClick);

            createGrid();
            populateClues();
        })();
    </script>
</body>
</html>